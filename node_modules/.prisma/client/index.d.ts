
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Propuesta
 * 
 */
export type Propuesta = $Result.DefaultSelection<Prisma.$PropuestaPayload>
/**
 * Model Actividad
 * 
 */
export type Actividad = $Result.DefaultSelection<Prisma.$ActividadPayload>
/**
 * Model Evidencia
 * 
 */
export type Evidencia = $Result.DefaultSelection<Prisma.$EvidenciaPayload>
/**
 * Model Comentario
 * 
 */
export type Comentario = $Result.DefaultSelection<Prisma.$ComentarioPayload>
/**
 * Model Prerequisito
 * 
 */
export type Prerequisito = $Result.DefaultSelection<Prisma.$PrerequisitoPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model EntregableFinal
 * 
 */
export type EntregableFinal = $Result.DefaultSelection<Prisma.$EntregableFinalPayload>
/**
 * Model Comite
 * 
 */
export type Comite = $Result.DefaultSelection<Prisma.$ComitePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  ESTUDIANTE: 'ESTUDIANTE',
  TUTOR: 'TUTOR',
  DIRECTOR: 'DIRECTOR',
  COORDINADOR: 'COORDINADOR',
  COMITE: 'COMITE',
  DOCENTE_INTEGRACION: 'DOCENTE_INTEGRACION'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const AreaInvestigacion: {
  INTELIGENCIA_ARTIFICIAL: 'INTELIGENCIA_ARTIFICIAL',
  CIBERSEGURIDAD: 'CIBERSEGURIDAD',
  DESARROLLO_SOFTWARE: 'DESARROLLO_SOFTWARE',
  CONTROL_CALIDAD: 'CONTROL_CALIDAD'
};

export type AreaInvestigacion = (typeof AreaInvestigacion)[keyof typeof AreaInvestigacion]


export const EstadoPropuesta: {
  PENDIENTE: 'PENDIENTE',
  APROBADA: 'APROBADA',
  APROBADA_CON_COMENTARIOS: 'APROBADA_CON_COMENTARIOS',
  RECHAZADA: 'RECHAZADA'
};

export type EstadoPropuesta = (typeof EstadoPropuesta)[keyof typeof EstadoPropuesta]


export const EstadoEvidencia: {
  ENTREGADO: 'ENTREGADO',
  NO_ENTREGADO: 'NO_ENTREGADO'
};

export type EstadoEvidencia = (typeof EstadoEvidencia)[keyof typeof EstadoEvidencia]


export const TipoEntregable: {
  TESIS: 'TESIS',
  MANUAL_USUARIO: 'MANUAL_USUARIO',
  REPOSITORIO: 'REPOSITORIO',
  ARTICULO: 'ARTICULO'
};

export type TipoEntregable = (typeof TipoEntregable)[keyof typeof TipoEntregable]


export const RolComite: {
  JURADO_1: 'JURADO_1',
  JURADO_2: 'JURADO_2',
  PRESIDENTE: 'PRESIDENTE'
};

export type RolComite = (typeof RolComite)[keyof typeof RolComite]


export const ResultadoDefensa: {
  APROBADO: 'APROBADO',
  REPROBADO: 'REPROBADO',
  PENDIENTE: 'PENDIENTE'
};

export type ResultadoDefensa = (typeof ResultadoDefensa)[keyof typeof ResultadoDefensa]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type AreaInvestigacion = $Enums.AreaInvestigacion

export const AreaInvestigacion: typeof $Enums.AreaInvestigacion

export type EstadoPropuesta = $Enums.EstadoPropuesta

export const EstadoPropuesta: typeof $Enums.EstadoPropuesta

export type EstadoEvidencia = $Enums.EstadoEvidencia

export const EstadoEvidencia: typeof $Enums.EstadoEvidencia

export type TipoEntregable = $Enums.TipoEntregable

export const TipoEntregable: typeof $Enums.TipoEntregable

export type RolComite = $Enums.RolComite

export const RolComite: typeof $Enums.RolComite

export type ResultadoDefensa = $Enums.ResultadoDefensa

export const ResultadoDefensa: typeof $Enums.ResultadoDefensa

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.propuesta`: Exposes CRUD operations for the **Propuesta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Propuestas
    * const propuestas = await prisma.propuesta.findMany()
    * ```
    */
  get propuesta(): Prisma.PropuestaDelegate<ExtArgs>;

  /**
   * `prisma.actividad`: Exposes CRUD operations for the **Actividad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividads
    * const actividads = await prisma.actividad.findMany()
    * ```
    */
  get actividad(): Prisma.ActividadDelegate<ExtArgs>;

  /**
   * `prisma.evidencia`: Exposes CRUD operations for the **Evidencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidencias
    * const evidencias = await prisma.evidencia.findMany()
    * ```
    */
  get evidencia(): Prisma.EvidenciaDelegate<ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **Comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.ComentarioDelegate<ExtArgs>;

  /**
   * `prisma.prerequisito`: Exposes CRUD operations for the **Prerequisito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prerequisitos
    * const prerequisitos = await prisma.prerequisito.findMany()
    * ```
    */
  get prerequisito(): Prisma.PrerequisitoDelegate<ExtArgs>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs>;

  /**
   * `prisma.entregableFinal`: Exposes CRUD operations for the **EntregableFinal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntregableFinals
    * const entregableFinals = await prisma.entregableFinal.findMany()
    * ```
    */
  get entregableFinal(): Prisma.EntregableFinalDelegate<ExtArgs>;

  /**
   * `prisma.comite`: Exposes CRUD operations for the **Comite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comites
    * const comites = await prisma.comite.findMany()
    * ```
    */
  get comite(): Prisma.ComiteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Propuesta: 'Propuesta',
    Actividad: 'Actividad',
    Evidencia: 'Evidencia',
    Comentario: 'Comentario',
    Prerequisito: 'Prerequisito',
    Notificacion: 'Notificacion',
    EntregableFinal: 'EntregableFinal',
    Comite: 'Comite'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "propuesta" | "actividad" | "evidencia" | "comentario" | "prerequisito" | "notificacion" | "entregableFinal" | "comite"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Propuesta: {
        payload: Prisma.$PropuestaPayload<ExtArgs>
        fields: Prisma.PropuestaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropuestaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropuestaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          findFirst: {
            args: Prisma.PropuestaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropuestaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          findMany: {
            args: Prisma.PropuestaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>[]
          }
          create: {
            args: Prisma.PropuestaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          createMany: {
            args: Prisma.PropuestaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropuestaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          update: {
            args: Prisma.PropuestaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          deleteMany: {
            args: Prisma.PropuestaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropuestaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropuestaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropuestaPayload>
          }
          aggregate: {
            args: Prisma.PropuestaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropuesta>
          }
          groupBy: {
            args: Prisma.PropuestaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropuestaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropuestaCountArgs<ExtArgs>
            result: $Utils.Optional<PropuestaCountAggregateOutputType> | number
          }
        }
      }
      Actividad: {
        payload: Prisma.$ActividadPayload<ExtArgs>
        fields: Prisma.ActividadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActividadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActividadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          findFirst: {
            args: Prisma.ActividadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActividadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          findMany: {
            args: Prisma.ActividadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>[]
          }
          create: {
            args: Prisma.ActividadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          createMany: {
            args: Prisma.ActividadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActividadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          update: {
            args: Prisma.ActividadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          deleteMany: {
            args: Prisma.ActividadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActividadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActividadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActividadPayload>
          }
          aggregate: {
            args: Prisma.ActividadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActividad>
          }
          groupBy: {
            args: Prisma.ActividadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActividadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActividadCountArgs<ExtArgs>
            result: $Utils.Optional<ActividadCountAggregateOutputType> | number
          }
        }
      }
      Evidencia: {
        payload: Prisma.$EvidenciaPayload<ExtArgs>
        fields: Prisma.EvidenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findFirst: {
            args: Prisma.EvidenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          findMany: {
            args: Prisma.EvidenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>[]
          }
          create: {
            args: Prisma.EvidenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          createMany: {
            args: Prisma.EvidenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvidenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          update: {
            args: Prisma.EvidenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          deleteMany: {
            args: Prisma.EvidenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvidenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenciaPayload>
          }
          aggregate: {
            args: Prisma.EvidenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidencia>
          }
          groupBy: {
            args: Prisma.EvidenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenciaCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenciaCountAggregateOutputType> | number
          }
        }
      }
      Comentario: {
        payload: Prisma.$ComentarioPayload<ExtArgs>
        fields: Prisma.ComentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findFirst: {
            args: Prisma.ComentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          findMany: {
            args: Prisma.ComentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>[]
          }
          create: {
            args: Prisma.ComentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          createMany: {
            args: Prisma.ComentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          update: {
            args: Prisma.ComentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          deleteMany: {
            args: Prisma.ComentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.ComentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      Prerequisito: {
        payload: Prisma.$PrerequisitoPayload<ExtArgs>
        fields: Prisma.PrerequisitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrerequisitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrerequisitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          findFirst: {
            args: Prisma.PrerequisitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrerequisitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          findMany: {
            args: Prisma.PrerequisitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>[]
          }
          create: {
            args: Prisma.PrerequisitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          createMany: {
            args: Prisma.PrerequisitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrerequisitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          update: {
            args: Prisma.PrerequisitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          deleteMany: {
            args: Prisma.PrerequisitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrerequisitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrerequisitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrerequisitoPayload>
          }
          aggregate: {
            args: Prisma.PrerequisitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrerequisito>
          }
          groupBy: {
            args: Prisma.PrerequisitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrerequisitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrerequisitoCountArgs<ExtArgs>
            result: $Utils.Optional<PrerequisitoCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      EntregableFinal: {
        payload: Prisma.$EntregableFinalPayload<ExtArgs>
        fields: Prisma.EntregableFinalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntregableFinalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntregableFinalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          findFirst: {
            args: Prisma.EntregableFinalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntregableFinalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          findMany: {
            args: Prisma.EntregableFinalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>[]
          }
          create: {
            args: Prisma.EntregableFinalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          createMany: {
            args: Prisma.EntregableFinalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntregableFinalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          update: {
            args: Prisma.EntregableFinalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          deleteMany: {
            args: Prisma.EntregableFinalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntregableFinalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntregableFinalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntregableFinalPayload>
          }
          aggregate: {
            args: Prisma.EntregableFinalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntregableFinal>
          }
          groupBy: {
            args: Prisma.EntregableFinalGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntregableFinalGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntregableFinalCountArgs<ExtArgs>
            result: $Utils.Optional<EntregableFinalCountAggregateOutputType> | number
          }
        }
      }
      Comite: {
        payload: Prisma.$ComitePayload<ExtArgs>
        fields: Prisma.ComiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          findFirst: {
            args: Prisma.ComiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          findMany: {
            args: Prisma.ComiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>[]
          }
          create: {
            args: Prisma.ComiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          createMany: {
            args: Prisma.ComiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          update: {
            args: Prisma.ComiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          deleteMany: {
            args: Prisma.ComiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComitePayload>
          }
          aggregate: {
            args: Prisma.ComiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComite>
          }
          groupBy: {
            args: Prisma.ComiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComiteCountArgs<ExtArgs>
            result: $Utils.Optional<ComiteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    propuestas: number
    actividadesCreadas: number
    comentarios: number
    notificaciones: number
    comiteAsignaciones: number
    prerequisitos: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuestas?: boolean | UsuarioCountOutputTypeCountPropuestasArgs
    actividadesCreadas?: boolean | UsuarioCountOutputTypeCountActividadesCreadasArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
    notificaciones?: boolean | UsuarioCountOutputTypeCountNotificacionesArgs
    comiteAsignaciones?: boolean | UsuarioCountOutputTypeCountComiteAsignacionesArgs
    prerequisitos?: boolean | UsuarioCountOutputTypeCountPrerequisitosArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPropuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropuestaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountActividadesCreadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComiteAsignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPrerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisitoWhereInput
  }


  /**
   * Count Type PropuestaCountOutputType
   */

  export type PropuestaCountOutputType = {
    actividades: number
    comiteAsignaciones: number
    entregablesFinales: number
  }

  export type PropuestaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades?: boolean | PropuestaCountOutputTypeCountActividadesArgs
    comiteAsignaciones?: boolean | PropuestaCountOutputTypeCountComiteAsignacionesArgs
    entregablesFinales?: boolean | PropuestaCountOutputTypeCountEntregablesFinalesArgs
  }

  // Custom InputTypes
  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropuestaCountOutputType
     */
    select?: PropuestaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountActividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadWhereInput
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountComiteAsignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
  }

  /**
   * PropuestaCountOutputType without action
   */
  export type PropuestaCountOutputTypeCountEntregablesFinalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntregableFinalWhereInput
  }


  /**
   * Count Type ActividadCountOutputType
   */

  export type ActividadCountOutputType = {
    evidencias: number
  }

  export type ActividadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencias?: boolean | ActividadCountOutputTypeCountEvidenciasArgs
  }

  // Custom InputTypes
  /**
   * ActividadCountOutputType without action
   */
  export type ActividadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActividadCountOutputType
     */
    select?: ActividadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActividadCountOutputType without action
   */
  export type ActividadCountOutputTypeCountEvidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
  }


  /**
   * Count Type EvidenciaCountOutputType
   */

  export type EvidenciaCountOutputType = {
    comentarios: number
  }

  export type EvidenciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentarios?: boolean | EvidenciaCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenciaCountOutputType
     */
    select?: EvidenciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvidenciaCountOutputType without action
   */
  export type EvidenciaCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    correoInstitucional: string | null
    clave: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    correoInstitucional: string | null
    clave: string | null
    rol: $Enums.Rol | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    cedula: number
    nombres: number
    apellidos: number
    correoInstitucional: number
    clave: number
    rol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    clave?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    clave?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    correoInstitucional?: true
    clave?: true
    rol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol: $Enums.Rol
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    correoInstitucional?: boolean
    clave?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    propuestas?: boolean | Usuario$propuestasArgs<ExtArgs>
    actividadesCreadas?: boolean | Usuario$actividadesCreadasArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>
    comiteAsignaciones?: boolean | Usuario$comiteAsignacionesArgs<ExtArgs>
    prerequisitos?: boolean | Usuario$prerequisitosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    correoInstitucional?: boolean
    clave?: boolean
    rol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuestas?: boolean | Usuario$propuestasArgs<ExtArgs>
    actividadesCreadas?: boolean | Usuario$actividadesCreadasArgs<ExtArgs>
    comentarios?: boolean | Usuario$comentariosArgs<ExtArgs>
    notificaciones?: boolean | Usuario$notificacionesArgs<ExtArgs>
    comiteAsignaciones?: boolean | Usuario$comiteAsignacionesArgs<ExtArgs>
    prerequisitos?: boolean | Usuario$prerequisitosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      propuestas: Prisma.$PropuestaPayload<ExtArgs>[]
      actividadesCreadas: Prisma.$ActividadPayload<ExtArgs>[]
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
      notificaciones: Prisma.$NotificacionPayload<ExtArgs>[]
      comiteAsignaciones: Prisma.$ComitePayload<ExtArgs>[]
      prerequisitos: Prisma.$PrerequisitoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cedula: string
      nombres: string
      apellidos: string
      correoInstitucional: string
      clave: string
      rol: $Enums.Rol
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuestas<T extends Usuario$propuestasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$propuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findMany"> | Null>
    actividadesCreadas<T extends Usuario$actividadesCreadasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$actividadesCreadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends Usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    notificaciones<T extends Usuario$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany"> | Null>
    comiteAsignaciones<T extends Usuario$comiteAsignacionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$comiteAsignacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany"> | Null>
    prerequisitos<T extends Usuario$prerequisitosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$prerequisitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly cedula: FieldRef<"Usuario", 'String'>
    readonly nombres: FieldRef<"Usuario", 'String'>
    readonly apellidos: FieldRef<"Usuario", 'String'>
    readonly correoInstitucional: FieldRef<"Usuario", 'String'>
    readonly clave: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.propuestas
   */
  export type Usuario$propuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    where?: PropuestaWhereInput
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    cursor?: PropuestaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Usuario.actividadesCreadas
   */
  export type Usuario$actividadesCreadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    where?: ActividadWhereInput
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    cursor?: ActividadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Usuario.comentarios
   */
  export type Usuario$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Usuario.notificaciones
   */
  export type Usuario$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Usuario.comiteAsignaciones
   */
  export type Usuario$comiteAsignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    cursor?: ComiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Usuario.prerequisitos
   */
  export type Usuario$prerequisitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    where?: PrerequisitoWhereInput
    orderBy?: PrerequisitoOrderByWithRelationInput | PrerequisitoOrderByWithRelationInput[]
    cursor?: PrerequisitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrerequisitoScalarFieldEnum | PrerequisitoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Propuesta
   */

  export type AggregatePropuesta = {
    _count: PropuestaCountAggregateOutputType | null
    _avg: PropuestaAvgAggregateOutputType | null
    _sum: PropuestaSumAggregateOutputType | null
    _min: PropuestaMinAggregateOutputType | null
    _max: PropuestaMaxAggregateOutputType | null
  }

  export type PropuestaAvgAggregateOutputType = {
    id: number | null
    fkEstudiante: number | null
    aprobado: number | null
  }

  export type PropuestaSumAggregateOutputType = {
    id: number | null
    fkEstudiante: number | null
    aprobado: number | null
  }

  export type PropuestaMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    objetivos: string | null
    problematica: string | null
    areaInvestigacion: $Enums.AreaInvestigacion | null
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date | null
    estado: $Enums.EstadoPropuesta | null
    fkEstudiante: number | null
    aprobado: number | null
  }

  export type PropuestaMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    objetivos: string | null
    problematica: string | null
    areaInvestigacion: $Enums.AreaInvestigacion | null
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date | null
    estado: $Enums.EstadoPropuesta | null
    fkEstudiante: number | null
    aprobado: number | null
  }

  export type PropuestaCountAggregateOutputType = {
    id: number
    titulo: number
    objetivos: number
    problematica: number
    areaInvestigacion: number
    alcance: number
    archivoUrl: number
    fechaPublicacion: number
    estado: number
    fkEstudiante: number
    aprobado: number
    _all: number
  }


  export type PropuestaAvgAggregateInputType = {
    id?: true
    fkEstudiante?: true
    aprobado?: true
  }

  export type PropuestaSumAggregateInputType = {
    id?: true
    fkEstudiante?: true
    aprobado?: true
  }

  export type PropuestaMinAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaInvestigacion?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    aprobado?: true
  }

  export type PropuestaMaxAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaInvestigacion?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    aprobado?: true
  }

  export type PropuestaCountAggregateInputType = {
    id?: true
    titulo?: true
    objetivos?: true
    problematica?: true
    areaInvestigacion?: true
    alcance?: true
    archivoUrl?: true
    fechaPublicacion?: true
    estado?: true
    fkEstudiante?: true
    aprobado?: true
    _all?: true
  }

  export type PropuestaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Propuesta to aggregate.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Propuestas
    **/
    _count?: true | PropuestaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropuestaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropuestaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropuestaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropuestaMaxAggregateInputType
  }

  export type GetPropuestaAggregateType<T extends PropuestaAggregateArgs> = {
        [P in keyof T & keyof AggregatePropuesta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropuesta[P]>
      : GetScalarType<T[P], AggregatePropuesta[P]>
  }




  export type PropuestaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropuestaWhereInput
    orderBy?: PropuestaOrderByWithAggregationInput | PropuestaOrderByWithAggregationInput[]
    by: PropuestaScalarFieldEnum[] | PropuestaScalarFieldEnum
    having?: PropuestaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropuestaCountAggregateInputType | true
    _avg?: PropuestaAvgAggregateInputType
    _sum?: PropuestaSumAggregateInputType
    _min?: PropuestaMinAggregateInputType
    _max?: PropuestaMaxAggregateInputType
  }

  export type PropuestaGroupByOutputType = {
    id: number
    titulo: string
    objetivos: string
    problematica: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance: string | null
    archivoUrl: string | null
    fechaPublicacion: Date
    estado: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado: number | null
    _count: PropuestaCountAggregateOutputType | null
    _avg: PropuestaAvgAggregateOutputType | null
    _sum: PropuestaSumAggregateOutputType | null
    _min: PropuestaMinAggregateOutputType | null
    _max: PropuestaMaxAggregateOutputType | null
  }

  type GetPropuestaGroupByPayload<T extends PropuestaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropuestaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropuestaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropuestaGroupByOutputType[P]>
            : GetScalarType<T[P], PropuestaGroupByOutputType[P]>
        }
      >
    >


  export type PropuestaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    objetivos?: boolean
    problematica?: boolean
    areaInvestigacion?: boolean
    alcance?: boolean
    archivoUrl?: boolean
    fechaPublicacion?: boolean
    estado?: boolean
    fkEstudiante?: boolean
    aprobado?: boolean
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
    actividades?: boolean | Propuesta$actividadesArgs<ExtArgs>
    comiteAsignaciones?: boolean | Propuesta$comiteAsignacionesArgs<ExtArgs>
    entregablesFinales?: boolean | Propuesta$entregablesFinalesArgs<ExtArgs>
    _count?: boolean | PropuestaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propuesta"]>


  export type PropuestaSelectScalar = {
    id?: boolean
    titulo?: boolean
    objetivos?: boolean
    problematica?: boolean
    areaInvestigacion?: boolean
    alcance?: boolean
    archivoUrl?: boolean
    fechaPublicacion?: boolean
    estado?: boolean
    fkEstudiante?: boolean
    aprobado?: boolean
  }

  export type PropuestaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
    actividades?: boolean | Propuesta$actividadesArgs<ExtArgs>
    comiteAsignaciones?: boolean | Propuesta$comiteAsignacionesArgs<ExtArgs>
    entregablesFinales?: boolean | Propuesta$entregablesFinalesArgs<ExtArgs>
    _count?: boolean | PropuestaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PropuestaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Propuesta"
    objects: {
      estudiante: Prisma.$UsuarioPayload<ExtArgs>
      actividades: Prisma.$ActividadPayload<ExtArgs>[]
      comiteAsignaciones: Prisma.$ComitePayload<ExtArgs>[]
      entregablesFinales: Prisma.$EntregableFinalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      objetivos: string
      problematica: string | null
      areaInvestigacion: $Enums.AreaInvestigacion
      alcance: string | null
      archivoUrl: string | null
      fechaPublicacion: Date
      estado: $Enums.EstadoPropuesta
      fkEstudiante: number
      aprobado: number | null
    }, ExtArgs["result"]["propuesta"]>
    composites: {}
  }

  type PropuestaGetPayload<S extends boolean | null | undefined | PropuestaDefaultArgs> = $Result.GetResult<Prisma.$PropuestaPayload, S>

  type PropuestaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PropuestaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropuestaCountAggregateInputType | true
    }

  export interface PropuestaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Propuesta'], meta: { name: 'Propuesta' } }
    /**
     * Find zero or one Propuesta that matches the filter.
     * @param {PropuestaFindUniqueArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropuestaFindUniqueArgs>(args: SelectSubset<T, PropuestaFindUniqueArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Propuesta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PropuestaFindUniqueOrThrowArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropuestaFindUniqueOrThrowArgs>(args: SelectSubset<T, PropuestaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Propuesta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindFirstArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropuestaFindFirstArgs>(args?: SelectSubset<T, PropuestaFindFirstArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Propuesta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindFirstOrThrowArgs} args - Arguments to find a Propuesta
     * @example
     * // Get one Propuesta
     * const propuesta = await prisma.propuesta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropuestaFindFirstOrThrowArgs>(args?: SelectSubset<T, PropuestaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Propuestas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Propuestas
     * const propuestas = await prisma.propuesta.findMany()
     * 
     * // Get first 10 Propuestas
     * const propuestas = await prisma.propuesta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propuestaWithIdOnly = await prisma.propuesta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropuestaFindManyArgs>(args?: SelectSubset<T, PropuestaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Propuesta.
     * @param {PropuestaCreateArgs} args - Arguments to create a Propuesta.
     * @example
     * // Create one Propuesta
     * const Propuesta = await prisma.propuesta.create({
     *   data: {
     *     // ... data to create a Propuesta
     *   }
     * })
     * 
     */
    create<T extends PropuestaCreateArgs>(args: SelectSubset<T, PropuestaCreateArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Propuestas.
     * @param {PropuestaCreateManyArgs} args - Arguments to create many Propuestas.
     * @example
     * // Create many Propuestas
     * const propuesta = await prisma.propuesta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropuestaCreateManyArgs>(args?: SelectSubset<T, PropuestaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Propuesta.
     * @param {PropuestaDeleteArgs} args - Arguments to delete one Propuesta.
     * @example
     * // Delete one Propuesta
     * const Propuesta = await prisma.propuesta.delete({
     *   where: {
     *     // ... filter to delete one Propuesta
     *   }
     * })
     * 
     */
    delete<T extends PropuestaDeleteArgs>(args: SelectSubset<T, PropuestaDeleteArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Propuesta.
     * @param {PropuestaUpdateArgs} args - Arguments to update one Propuesta.
     * @example
     * // Update one Propuesta
     * const propuesta = await prisma.propuesta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropuestaUpdateArgs>(args: SelectSubset<T, PropuestaUpdateArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Propuestas.
     * @param {PropuestaDeleteManyArgs} args - Arguments to filter Propuestas to delete.
     * @example
     * // Delete a few Propuestas
     * const { count } = await prisma.propuesta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropuestaDeleteManyArgs>(args?: SelectSubset<T, PropuestaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Propuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Propuestas
     * const propuesta = await prisma.propuesta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropuestaUpdateManyArgs>(args: SelectSubset<T, PropuestaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Propuesta.
     * @param {PropuestaUpsertArgs} args - Arguments to update or create a Propuesta.
     * @example
     * // Update or create a Propuesta
     * const propuesta = await prisma.propuesta.upsert({
     *   create: {
     *     // ... data to create a Propuesta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Propuesta we want to update
     *   }
     * })
     */
    upsert<T extends PropuestaUpsertArgs>(args: SelectSubset<T, PropuestaUpsertArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Propuestas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaCountArgs} args - Arguments to filter Propuestas to count.
     * @example
     * // Count the number of Propuestas
     * const count = await prisma.propuesta.count({
     *   where: {
     *     // ... the filter for the Propuestas we want to count
     *   }
     * })
    **/
    count<T extends PropuestaCountArgs>(
      args?: Subset<T, PropuestaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropuestaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Propuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropuestaAggregateArgs>(args: Subset<T, PropuestaAggregateArgs>): Prisma.PrismaPromise<GetPropuestaAggregateType<T>>

    /**
     * Group by Propuesta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropuestaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropuestaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropuestaGroupByArgs['orderBy'] }
        : { orderBy?: PropuestaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropuestaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropuestaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Propuesta model
   */
  readonly fields: PropuestaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Propuesta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropuestaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actividades<T extends Propuesta$actividadesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$actividadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findMany"> | Null>
    comiteAsignaciones<T extends Propuesta$comiteAsignacionesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$comiteAsignacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany"> | Null>
    entregablesFinales<T extends Propuesta$entregablesFinalesArgs<ExtArgs> = {}>(args?: Subset<T, Propuesta$entregablesFinalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Propuesta model
   */ 
  interface PropuestaFieldRefs {
    readonly id: FieldRef<"Propuesta", 'Int'>
    readonly titulo: FieldRef<"Propuesta", 'String'>
    readonly objetivos: FieldRef<"Propuesta", 'String'>
    readonly problematica: FieldRef<"Propuesta", 'String'>
    readonly areaInvestigacion: FieldRef<"Propuesta", 'AreaInvestigacion'>
    readonly alcance: FieldRef<"Propuesta", 'String'>
    readonly archivoUrl: FieldRef<"Propuesta", 'String'>
    readonly fechaPublicacion: FieldRef<"Propuesta", 'DateTime'>
    readonly estado: FieldRef<"Propuesta", 'EstadoPropuesta'>
    readonly fkEstudiante: FieldRef<"Propuesta", 'Int'>
    readonly aprobado: FieldRef<"Propuesta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Propuesta findUnique
   */
  export type PropuestaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta findUniqueOrThrow
   */
  export type PropuestaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta findFirst
   */
  export type PropuestaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Propuestas.
     */
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta findFirstOrThrow
   */
  export type PropuestaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuesta to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Propuestas.
     */
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta findMany
   */
  export type PropuestaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter, which Propuestas to fetch.
     */
    where?: PropuestaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Propuestas to fetch.
     */
    orderBy?: PropuestaOrderByWithRelationInput | PropuestaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Propuestas.
     */
    cursor?: PropuestaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Propuestas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Propuestas.
     */
    skip?: number
    distinct?: PropuestaScalarFieldEnum | PropuestaScalarFieldEnum[]
  }

  /**
   * Propuesta create
   */
  export type PropuestaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The data needed to create a Propuesta.
     */
    data: XOR<PropuestaCreateInput, PropuestaUncheckedCreateInput>
  }

  /**
   * Propuesta createMany
   */
  export type PropuestaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Propuestas.
     */
    data: PropuestaCreateManyInput | PropuestaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Propuesta update
   */
  export type PropuestaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The data needed to update a Propuesta.
     */
    data: XOR<PropuestaUpdateInput, PropuestaUncheckedUpdateInput>
    /**
     * Choose, which Propuesta to update.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta updateMany
   */
  export type PropuestaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Propuestas.
     */
    data: XOR<PropuestaUpdateManyMutationInput, PropuestaUncheckedUpdateManyInput>
    /**
     * Filter which Propuestas to update
     */
    where?: PropuestaWhereInput
  }

  /**
   * Propuesta upsert
   */
  export type PropuestaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * The filter to search for the Propuesta to update in case it exists.
     */
    where: PropuestaWhereUniqueInput
    /**
     * In case the Propuesta found by the `where` argument doesn't exist, create a new Propuesta with this data.
     */
    create: XOR<PropuestaCreateInput, PropuestaUncheckedCreateInput>
    /**
     * In case the Propuesta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropuestaUpdateInput, PropuestaUncheckedUpdateInput>
  }

  /**
   * Propuesta delete
   */
  export type PropuestaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
    /**
     * Filter which Propuesta to delete.
     */
    where: PropuestaWhereUniqueInput
  }

  /**
   * Propuesta deleteMany
   */
  export type PropuestaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Propuestas to delete
     */
    where?: PropuestaWhereInput
  }

  /**
   * Propuesta.actividades
   */
  export type Propuesta$actividadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    where?: ActividadWhereInput
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    cursor?: ActividadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Propuesta.comiteAsignaciones
   */
  export type Propuesta$comiteAsignacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    cursor?: ComiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Propuesta.entregablesFinales
   */
  export type Propuesta$entregablesFinalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    where?: EntregableFinalWhereInput
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    cursor?: EntregableFinalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * Propuesta without action
   */
  export type PropuestaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Propuesta
     */
    select?: PropuestaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropuestaInclude<ExtArgs> | null
  }


  /**
   * Model Actividad
   */

  export type AggregateActividad = {
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  export type ActividadAvgAggregateOutputType = {
    idActividades: number | null
    propuestasId: number | null
    usuariosId: number | null
  }

  export type ActividadSumAggregateOutputType = {
    idActividades: number | null
    propuestasId: number | null
    usuariosId: number | null
  }

  export type ActividadMinAggregateOutputType = {
    idActividades: number | null
    nombre: string | null
    descripcion: string | null
    propuestasId: number | null
    usuariosId: number | null
  }

  export type ActividadMaxAggregateOutputType = {
    idActividades: number | null
    nombre: string | null
    descripcion: string | null
    propuestasId: number | null
    usuariosId: number | null
  }

  export type ActividadCountAggregateOutputType = {
    idActividades: number
    nombre: number
    descripcion: number
    propuestasId: number
    usuariosId: number
    _all: number
  }


  export type ActividadAvgAggregateInputType = {
    idActividades?: true
    propuestasId?: true
    usuariosId?: true
  }

  export type ActividadSumAggregateInputType = {
    idActividades?: true
    propuestasId?: true
    usuariosId?: true
  }

  export type ActividadMinAggregateInputType = {
    idActividades?: true
    nombre?: true
    descripcion?: true
    propuestasId?: true
    usuariosId?: true
  }

  export type ActividadMaxAggregateInputType = {
    idActividades?: true
    nombre?: true
    descripcion?: true
    propuestasId?: true
    usuariosId?: true
  }

  export type ActividadCountAggregateInputType = {
    idActividades?: true
    nombre?: true
    descripcion?: true
    propuestasId?: true
    usuariosId?: true
    _all?: true
  }

  export type ActividadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actividad to aggregate.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actividads
    **/
    _count?: true | ActividadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActividadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActividadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActividadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActividadMaxAggregateInputType
  }

  export type GetActividadAggregateType<T extends ActividadAggregateArgs> = {
        [P in keyof T & keyof AggregateActividad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividad[P]>
      : GetScalarType<T[P], AggregateActividad[P]>
  }




  export type ActividadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActividadWhereInput
    orderBy?: ActividadOrderByWithAggregationInput | ActividadOrderByWithAggregationInput[]
    by: ActividadScalarFieldEnum[] | ActividadScalarFieldEnum
    having?: ActividadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActividadCountAggregateInputType | true
    _avg?: ActividadAvgAggregateInputType
    _sum?: ActividadSumAggregateInputType
    _min?: ActividadMinAggregateInputType
    _max?: ActividadMaxAggregateInputType
  }

  export type ActividadGroupByOutputType = {
    idActividades: number
    nombre: string | null
    descripcion: string | null
    propuestasId: number
    usuariosId: number
    _count: ActividadCountAggregateOutputType | null
    _avg: ActividadAvgAggregateOutputType | null
    _sum: ActividadSumAggregateOutputType | null
    _min: ActividadMinAggregateOutputType | null
    _max: ActividadMaxAggregateOutputType | null
  }

  type GetActividadGroupByPayload<T extends ActividadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActividadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActividadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActividadGroupByOutputType[P]>
            : GetScalarType<T[P], ActividadGroupByOutputType[P]>
        }
      >
    >


  export type ActividadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idActividades?: boolean
    nombre?: boolean
    descripcion?: boolean
    propuestasId?: boolean
    usuariosId?: boolean
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    evidencias?: boolean | Actividad$evidenciasArgs<ExtArgs>
    _count?: boolean | ActividadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividad"]>


  export type ActividadSelectScalar = {
    idActividades?: boolean
    nombre?: boolean
    descripcion?: boolean
    propuestasId?: boolean
    usuariosId?: boolean
  }

  export type ActividadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    evidencias?: boolean | Actividad$evidenciasArgs<ExtArgs>
    _count?: boolean | ActividadCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ActividadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Actividad"
    objects: {
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      evidencias: Prisma.$EvidenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idActividades: number
      nombre: string | null
      descripcion: string | null
      propuestasId: number
      usuariosId: number
    }, ExtArgs["result"]["actividad"]>
    composites: {}
  }

  type ActividadGetPayload<S extends boolean | null | undefined | ActividadDefaultArgs> = $Result.GetResult<Prisma.$ActividadPayload, S>

  type ActividadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActividadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActividadCountAggregateInputType | true
    }

  export interface ActividadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Actividad'], meta: { name: 'Actividad' } }
    /**
     * Find zero or one Actividad that matches the filter.
     * @param {ActividadFindUniqueArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActividadFindUniqueArgs>(args: SelectSubset<T, ActividadFindUniqueArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Actividad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActividadFindUniqueOrThrowArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActividadFindUniqueOrThrowArgs>(args: SelectSubset<T, ActividadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Actividad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindFirstArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActividadFindFirstArgs>(args?: SelectSubset<T, ActividadFindFirstArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Actividad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindFirstOrThrowArgs} args - Arguments to find a Actividad
     * @example
     * // Get one Actividad
     * const actividad = await prisma.actividad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActividadFindFirstOrThrowArgs>(args?: SelectSubset<T, ActividadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actividads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividads
     * const actividads = await prisma.actividad.findMany()
     * 
     * // Get first 10 Actividads
     * const actividads = await prisma.actividad.findMany({ take: 10 })
     * 
     * // Only select the `idActividades`
     * const actividadWithIdActividadesOnly = await prisma.actividad.findMany({ select: { idActividades: true } })
     * 
     */
    findMany<T extends ActividadFindManyArgs>(args?: SelectSubset<T, ActividadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Actividad.
     * @param {ActividadCreateArgs} args - Arguments to create a Actividad.
     * @example
     * // Create one Actividad
     * const Actividad = await prisma.actividad.create({
     *   data: {
     *     // ... data to create a Actividad
     *   }
     * })
     * 
     */
    create<T extends ActividadCreateArgs>(args: SelectSubset<T, ActividadCreateArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actividads.
     * @param {ActividadCreateManyArgs} args - Arguments to create many Actividads.
     * @example
     * // Create many Actividads
     * const actividad = await prisma.actividad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActividadCreateManyArgs>(args?: SelectSubset<T, ActividadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actividad.
     * @param {ActividadDeleteArgs} args - Arguments to delete one Actividad.
     * @example
     * // Delete one Actividad
     * const Actividad = await prisma.actividad.delete({
     *   where: {
     *     // ... filter to delete one Actividad
     *   }
     * })
     * 
     */
    delete<T extends ActividadDeleteArgs>(args: SelectSubset<T, ActividadDeleteArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Actividad.
     * @param {ActividadUpdateArgs} args - Arguments to update one Actividad.
     * @example
     * // Update one Actividad
     * const actividad = await prisma.actividad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActividadUpdateArgs>(args: SelectSubset<T, ActividadUpdateArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actividads.
     * @param {ActividadDeleteManyArgs} args - Arguments to filter Actividads to delete.
     * @example
     * // Delete a few Actividads
     * const { count } = await prisma.actividad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActividadDeleteManyArgs>(args?: SelectSubset<T, ActividadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividads
     * const actividad = await prisma.actividad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActividadUpdateManyArgs>(args: SelectSubset<T, ActividadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividad.
     * @param {ActividadUpsertArgs} args - Arguments to update or create a Actividad.
     * @example
     * // Update or create a Actividad
     * const actividad = await prisma.actividad.upsert({
     *   create: {
     *     // ... data to create a Actividad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividad we want to update
     *   }
     * })
     */
    upsert<T extends ActividadUpsertArgs>(args: SelectSubset<T, ActividadUpsertArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actividads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadCountArgs} args - Arguments to filter Actividads to count.
     * @example
     * // Count the number of Actividads
     * const count = await prisma.actividad.count({
     *   where: {
     *     // ... the filter for the Actividads we want to count
     *   }
     * })
    **/
    count<T extends ActividadCountArgs>(
      args?: Subset<T, ActividadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActividadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActividadAggregateArgs>(args: Subset<T, ActividadAggregateArgs>): Prisma.PrismaPromise<GetActividadAggregateType<T>>

    /**
     * Group by Actividad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActividadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActividadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActividadGroupByArgs['orderBy'] }
        : { orderBy?: ActividadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActividadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Actividad model
   */
  readonly fields: ActividadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actividad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActividadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evidencias<T extends Actividad$evidenciasArgs<ExtArgs> = {}>(args?: Subset<T, Actividad$evidenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Actividad model
   */ 
  interface ActividadFieldRefs {
    readonly idActividades: FieldRef<"Actividad", 'Int'>
    readonly nombre: FieldRef<"Actividad", 'String'>
    readonly descripcion: FieldRef<"Actividad", 'String'>
    readonly propuestasId: FieldRef<"Actividad", 'Int'>
    readonly usuariosId: FieldRef<"Actividad", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Actividad findUnique
   */
  export type ActividadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad findUniqueOrThrow
   */
  export type ActividadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad findFirst
   */
  export type ActividadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actividads.
     */
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad findFirstOrThrow
   */
  export type ActividadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividad to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actividads.
     */
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad findMany
   */
  export type ActividadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter, which Actividads to fetch.
     */
    where?: ActividadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actividads to fetch.
     */
    orderBy?: ActividadOrderByWithRelationInput | ActividadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actividads.
     */
    cursor?: ActividadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actividads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actividads.
     */
    skip?: number
    distinct?: ActividadScalarFieldEnum | ActividadScalarFieldEnum[]
  }

  /**
   * Actividad create
   */
  export type ActividadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The data needed to create a Actividad.
     */
    data: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
  }

  /**
   * Actividad createMany
   */
  export type ActividadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actividads.
     */
    data: ActividadCreateManyInput | ActividadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actividad update
   */
  export type ActividadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The data needed to update a Actividad.
     */
    data: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
    /**
     * Choose, which Actividad to update.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad updateMany
   */
  export type ActividadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actividads.
     */
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyInput>
    /**
     * Filter which Actividads to update
     */
    where?: ActividadWhereInput
  }

  /**
   * Actividad upsert
   */
  export type ActividadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * The filter to search for the Actividad to update in case it exists.
     */
    where: ActividadWhereUniqueInput
    /**
     * In case the Actividad found by the `where` argument doesn't exist, create a new Actividad with this data.
     */
    create: XOR<ActividadCreateInput, ActividadUncheckedCreateInput>
    /**
     * In case the Actividad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActividadUpdateInput, ActividadUncheckedUpdateInput>
  }

  /**
   * Actividad delete
   */
  export type ActividadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
    /**
     * Filter which Actividad to delete.
     */
    where: ActividadWhereUniqueInput
  }

  /**
   * Actividad deleteMany
   */
  export type ActividadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actividads to delete
     */
    where?: ActividadWhereInput
  }

  /**
   * Actividad.evidencias
   */
  export type Actividad$evidenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    cursor?: EvidenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Actividad without action
   */
  export type ActividadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actividad
     */
    select?: ActividadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActividadInclude<ExtArgs> | null
  }


  /**
   * Model Evidencia
   */

  export type AggregateEvidencia = {
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  export type EvidenciaAvgAggregateOutputType = {
    id: number | null
    semana: number | null
    calificacion: Decimal | null
    actividadesId: number | null
  }

  export type EvidenciaSumAggregateOutputType = {
    id: number | null
    semana: number | null
    calificacion: Decimal | null
    actividadesId: number | null
  }

  export type EvidenciaMinAggregateOutputType = {
    id: number | null
    semana: number | null
    contenido: string | null
    archivoUrl: string | null
    fechaEntrega: Date | null
    estado: $Enums.EstadoEvidencia | null
    calificacion: Decimal | null
    actividadesId: number | null
  }

  export type EvidenciaMaxAggregateOutputType = {
    id: number | null
    semana: number | null
    contenido: string | null
    archivoUrl: string | null
    fechaEntrega: Date | null
    estado: $Enums.EstadoEvidencia | null
    calificacion: Decimal | null
    actividadesId: number | null
  }

  export type EvidenciaCountAggregateOutputType = {
    id: number
    semana: number
    contenido: number
    archivoUrl: number
    fechaEntrega: number
    estado: number
    calificacion: number
    actividadesId: number
    _all: number
  }


  export type EvidenciaAvgAggregateInputType = {
    id?: true
    semana?: true
    calificacion?: true
    actividadesId?: true
  }

  export type EvidenciaSumAggregateInputType = {
    id?: true
    semana?: true
    calificacion?: true
    actividadesId?: true
  }

  export type EvidenciaMinAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadesId?: true
  }

  export type EvidenciaMaxAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadesId?: true
  }

  export type EvidenciaCountAggregateInputType = {
    id?: true
    semana?: true
    contenido?: true
    archivoUrl?: true
    fechaEntrega?: true
    estado?: true
    calificacion?: true
    actividadesId?: true
    _all?: true
  }

  export type EvidenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencia to aggregate.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidencias
    **/
    _count?: true | EvidenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenciaMaxAggregateInputType
  }

  export type GetEvidenciaAggregateType<T extends EvidenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidencia[P]>
      : GetScalarType<T[P], AggregateEvidencia[P]>
  }




  export type EvidenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenciaWhereInput
    orderBy?: EvidenciaOrderByWithAggregationInput | EvidenciaOrderByWithAggregationInput[]
    by: EvidenciaScalarFieldEnum[] | EvidenciaScalarFieldEnum
    having?: EvidenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenciaCountAggregateInputType | true
    _avg?: EvidenciaAvgAggregateInputType
    _sum?: EvidenciaSumAggregateInputType
    _min?: EvidenciaMinAggregateInputType
    _max?: EvidenciaMaxAggregateInputType
  }

  export type EvidenciaGroupByOutputType = {
    id: number
    semana: number
    contenido: string
    archivoUrl: string | null
    fechaEntrega: Date
    estado: $Enums.EstadoEvidencia
    calificacion: Decimal | null
    actividadesId: number
    _count: EvidenciaCountAggregateOutputType | null
    _avg: EvidenciaAvgAggregateOutputType | null
    _sum: EvidenciaSumAggregateOutputType | null
    _min: EvidenciaMinAggregateOutputType | null
    _max: EvidenciaMaxAggregateOutputType | null
  }

  type GetEvidenciaGroupByPayload<T extends EvidenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenciaGroupByOutputType[P]>
        }
      >
    >


  export type EvidenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    semana?: boolean
    contenido?: boolean
    archivoUrl?: boolean
    fechaEntrega?: boolean
    estado?: boolean
    calificacion?: boolean
    actividadesId?: boolean
    actividad?: boolean | ActividadDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidencia"]>


  export type EvidenciaSelectScalar = {
    id?: boolean
    semana?: boolean
    contenido?: boolean
    archivoUrl?: boolean
    fechaEntrega?: boolean
    estado?: boolean
    calificacion?: boolean
    actividadesId?: boolean
  }

  export type EvidenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividad?: boolean | ActividadDefaultArgs<ExtArgs>
    comentarios?: boolean | Evidencia$comentariosArgs<ExtArgs>
    _count?: boolean | EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EvidenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidencia"
    objects: {
      actividad: Prisma.$ActividadPayload<ExtArgs>
      comentarios: Prisma.$ComentarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      semana: number
      contenido: string
      archivoUrl: string | null
      fechaEntrega: Date
      estado: $Enums.EstadoEvidencia
      calificacion: Prisma.Decimal | null
      actividadesId: number
    }, ExtArgs["result"]["evidencia"]>
    composites: {}
  }

  type EvidenciaGetPayload<S extends boolean | null | undefined | EvidenciaDefaultArgs> = $Result.GetResult<Prisma.$EvidenciaPayload, S>

  type EvidenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvidenciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvidenciaCountAggregateInputType | true
    }

  export interface EvidenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidencia'], meta: { name: 'Evidencia' } }
    /**
     * Find zero or one Evidencia that matches the filter.
     * @param {EvidenciaFindUniqueArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenciaFindUniqueArgs>(args: SelectSubset<T, EvidenciaFindUniqueArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evidencia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvidenciaFindUniqueOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenciaFindFirstArgs>(args?: SelectSubset<T, EvidenciaFindFirstArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evidencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindFirstOrThrowArgs} args - Arguments to find a Evidencia
     * @example
     * // Get one Evidencia
     * const evidencia = await prisma.evidencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Evidencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidencias
     * const evidencias = await prisma.evidencia.findMany()
     * 
     * // Get first 10 Evidencias
     * const evidencias = await prisma.evidencia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenciaWithIdOnly = await prisma.evidencia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenciaFindManyArgs>(args?: SelectSubset<T, EvidenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evidencia.
     * @param {EvidenciaCreateArgs} args - Arguments to create a Evidencia.
     * @example
     * // Create one Evidencia
     * const Evidencia = await prisma.evidencia.create({
     *   data: {
     *     // ... data to create a Evidencia
     *   }
     * })
     * 
     */
    create<T extends EvidenciaCreateArgs>(args: SelectSubset<T, EvidenciaCreateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Evidencias.
     * @param {EvidenciaCreateManyArgs} args - Arguments to create many Evidencias.
     * @example
     * // Create many Evidencias
     * const evidencia = await prisma.evidencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenciaCreateManyArgs>(args?: SelectSubset<T, EvidenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evidencia.
     * @param {EvidenciaDeleteArgs} args - Arguments to delete one Evidencia.
     * @example
     * // Delete one Evidencia
     * const Evidencia = await prisma.evidencia.delete({
     *   where: {
     *     // ... filter to delete one Evidencia
     *   }
     * })
     * 
     */
    delete<T extends EvidenciaDeleteArgs>(args: SelectSubset<T, EvidenciaDeleteArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evidencia.
     * @param {EvidenciaUpdateArgs} args - Arguments to update one Evidencia.
     * @example
     * // Update one Evidencia
     * const evidencia = await prisma.evidencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenciaUpdateArgs>(args: SelectSubset<T, EvidenciaUpdateArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Evidencias.
     * @param {EvidenciaDeleteManyArgs} args - Arguments to filter Evidencias to delete.
     * @example
     * // Delete a few Evidencias
     * const { count } = await prisma.evidencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenciaDeleteManyArgs>(args?: SelectSubset<T, EvidenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidencias
     * const evidencia = await prisma.evidencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenciaUpdateManyArgs>(args: SelectSubset<T, EvidenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evidencia.
     * @param {EvidenciaUpsertArgs} args - Arguments to update or create a Evidencia.
     * @example
     * // Update or create a Evidencia
     * const evidencia = await prisma.evidencia.upsert({
     *   create: {
     *     // ... data to create a Evidencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidencia we want to update
     *   }
     * })
     */
    upsert<T extends EvidenciaUpsertArgs>(args: SelectSubset<T, EvidenciaUpsertArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Evidencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaCountArgs} args - Arguments to filter Evidencias to count.
     * @example
     * // Count the number of Evidencias
     * const count = await prisma.evidencia.count({
     *   where: {
     *     // ... the filter for the Evidencias we want to count
     *   }
     * })
    **/
    count<T extends EvidenciaCountArgs>(
      args?: Subset<T, EvidenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenciaAggregateArgs>(args: Subset<T, EvidenciaAggregateArgs>): Prisma.PrismaPromise<GetEvidenciaAggregateType<T>>

    /**
     * Group by Evidencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenciaGroupByArgs['orderBy'] }
        : { orderBy?: EvidenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidencia model
   */
  readonly fields: EvidenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actividad<T extends ActividadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActividadDefaultArgs<ExtArgs>>): Prisma__ActividadClient<$Result.GetResult<Prisma.$ActividadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comentarios<T extends Evidencia$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, Evidencia$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidencia model
   */ 
  interface EvidenciaFieldRefs {
    readonly id: FieldRef<"Evidencia", 'Int'>
    readonly semana: FieldRef<"Evidencia", 'Int'>
    readonly contenido: FieldRef<"Evidencia", 'String'>
    readonly archivoUrl: FieldRef<"Evidencia", 'String'>
    readonly fechaEntrega: FieldRef<"Evidencia", 'DateTime'>
    readonly estado: FieldRef<"Evidencia", 'EstadoEvidencia'>
    readonly calificacion: FieldRef<"Evidencia", 'Decimal'>
    readonly actividadesId: FieldRef<"Evidencia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Evidencia findUnique
   */
  export type EvidenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findUniqueOrThrow
   */
  export type EvidenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia findFirst
   */
  export type EvidenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findFirstOrThrow
   */
  export type EvidenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencia to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidencias.
     */
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia findMany
   */
  export type EvidenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter, which Evidencias to fetch.
     */
    where?: EvidenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidencias to fetch.
     */
    orderBy?: EvidenciaOrderByWithRelationInput | EvidenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidencias.
     */
    cursor?: EvidenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidencias.
     */
    skip?: number
    distinct?: EvidenciaScalarFieldEnum | EvidenciaScalarFieldEnum[]
  }

  /**
   * Evidencia create
   */
  export type EvidenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidencia.
     */
    data: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
  }

  /**
   * Evidencia createMany
   */
  export type EvidenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidencias.
     */
    data: EvidenciaCreateManyInput | EvidenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidencia update
   */
  export type EvidenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidencia.
     */
    data: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
    /**
     * Choose, which Evidencia to update.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia updateMany
   */
  export type EvidenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidencias.
     */
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyInput>
    /**
     * Filter which Evidencias to update
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia upsert
   */
  export type EvidenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidencia to update in case it exists.
     */
    where: EvidenciaWhereUniqueInput
    /**
     * In case the Evidencia found by the `where` argument doesn't exist, create a new Evidencia with this data.
     */
    create: XOR<EvidenciaCreateInput, EvidenciaUncheckedCreateInput>
    /**
     * In case the Evidencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenciaUpdateInput, EvidenciaUncheckedUpdateInput>
  }

  /**
   * Evidencia delete
   */
  export type EvidenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
    /**
     * Filter which Evidencia to delete.
     */
    where: EvidenciaWhereUniqueInput
  }

  /**
   * Evidencia deleteMany
   */
  export type EvidenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidencias to delete
     */
    where?: EvidenciaWhereInput
  }

  /**
   * Evidencia.comentarios
   */
  export type Evidencia$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    cursor?: ComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Evidencia without action
   */
  export type EvidenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidencia
     */
    select?: EvidenciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenciaInclude<ExtArgs> | null
  }


  /**
   * Model Comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    idComentarios: number | null
    evidenciaId: number | null
    usuariosId: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    idComentarios: number | null
    evidenciaId: number | null
    usuariosId: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    idComentarios: number | null
    descripcion: string | null
    evidenciaId: number | null
    usuariosId: number | null
  }

  export type ComentarioMaxAggregateOutputType = {
    idComentarios: number | null
    descripcion: string | null
    evidenciaId: number | null
    usuariosId: number | null
  }

  export type ComentarioCountAggregateOutputType = {
    idComentarios: number
    descripcion: number
    evidenciaId: number
    usuariosId: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    idComentarios?: true
    evidenciaId?: true
    usuariosId?: true
  }

  export type ComentarioSumAggregateInputType = {
    idComentarios?: true
    evidenciaId?: true
    usuariosId?: true
  }

  export type ComentarioMinAggregateInputType = {
    idComentarios?: true
    descripcion?: true
    evidenciaId?: true
    usuariosId?: true
  }

  export type ComentarioMaxAggregateInputType = {
    idComentarios?: true
    descripcion?: true
    evidenciaId?: true
    usuariosId?: true
  }

  export type ComentarioCountAggregateInputType = {
    idComentarios?: true
    descripcion?: true
    evidenciaId?: true
    usuariosId?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentario to aggregate.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type ComentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComentarioWhereInput
    orderBy?: ComentarioOrderByWithAggregationInput | ComentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: ComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    idComentarios: number
    descripcion: string | null
    evidenciaId: number
    usuariosId: number
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends ComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type ComentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComentarios?: boolean
    descripcion?: boolean
    evidenciaId?: boolean
    usuariosId?: boolean
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>


  export type ComentarioSelectScalar = {
    idComentarios?: boolean
    descripcion?: boolean
    evidenciaId?: boolean
    usuariosId?: boolean
  }

  export type ComentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidencia?: boolean | EvidenciaDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comentario"
    objects: {
      evidencia: Prisma.$EvidenciaPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idComentarios: number
      descripcion: string | null
      evidenciaId: number
      usuariosId: number
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type ComentarioGetPayload<S extends boolean | null | undefined | ComentarioDefaultArgs> = $Result.GetResult<Prisma.$ComentarioPayload, S>

  type ComentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface ComentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comentario'], meta: { name: 'Comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {ComentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComentarioFindUniqueArgs>(args: SelectSubset<T, ComentarioFindUniqueArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ComentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComentarioFindFirstArgs>(args?: SelectSubset<T, ComentarioFindFirstArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ComentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `idComentarios`
     * const comentarioWithIdComentariosOnly = await prisma.comentario.findMany({ select: { idComentarios: true } })
     * 
     */
    findMany<T extends ComentarioFindManyArgs>(args?: SelectSubset<T, ComentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comentario.
     * @param {ComentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends ComentarioCreateArgs>(args: SelectSubset<T, ComentarioCreateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comentarios.
     * @param {ComentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComentarioCreateManyArgs>(args?: SelectSubset<T, ComentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentario.
     * @param {ComentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends ComentarioDeleteArgs>(args: SelectSubset<T, ComentarioDeleteArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {ComentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComentarioUpdateArgs>(args: SelectSubset<T, ComentarioUpdateArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {ComentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComentarioDeleteManyArgs>(args?: SelectSubset<T, ComentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComentarioUpdateManyArgs>(args: SelectSubset<T, ComentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {ComentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends ComentarioUpsertArgs>(args: SelectSubset<T, ComentarioUpsertArgs<ExtArgs>>): Prisma__ComentarioClient<$Result.GetResult<Prisma.$ComentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends ComentarioCountArgs>(
      args?: Subset<T, ComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComentarioGroupByArgs['orderBy'] }
        : { orderBy?: ComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comentario model
   */
  readonly fields: ComentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidencia<T extends EvidenciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvidenciaDefaultArgs<ExtArgs>>): Prisma__EvidenciaClient<$Result.GetResult<Prisma.$EvidenciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comentario model
   */ 
  interface ComentarioFieldRefs {
    readonly idComentarios: FieldRef<"Comentario", 'Int'>
    readonly descripcion: FieldRef<"Comentario", 'String'>
    readonly evidenciaId: FieldRef<"Comentario", 'Int'>
    readonly usuariosId: FieldRef<"Comentario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comentario findUnique
   */
  export type ComentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findUniqueOrThrow
   */
  export type ComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario findFirst
   */
  export type ComentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findFirstOrThrow
   */
  export type ComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentario to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario findMany
   */
  export type ComentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter, which Comentarios to fetch.
     */
    where?: ComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comentarios to fetch.
     */
    orderBy?: ComentarioOrderByWithRelationInput | ComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comentarios.
     */
    cursor?: ComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * Comentario create
   */
  export type ComentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Comentario.
     */
    data: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
  }

  /**
   * Comentario createMany
   */
  export type ComentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comentarios.
     */
    data: ComentarioCreateManyInput | ComentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comentario update
   */
  export type ComentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Comentario.
     */
    data: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
    /**
     * Choose, which Comentario to update.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario updateMany
   */
  export type ComentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comentarios.
     */
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyInput>
    /**
     * Filter which Comentarios to update
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario upsert
   */
  export type ComentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Comentario to update in case it exists.
     */
    where: ComentarioWhereUniqueInput
    /**
     * In case the Comentario found by the `where` argument doesn't exist, create a new Comentario with this data.
     */
    create: XOR<ComentarioCreateInput, ComentarioUncheckedCreateInput>
    /**
     * In case the Comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComentarioUpdateInput, ComentarioUncheckedUpdateInput>
  }

  /**
   * Comentario delete
   */
  export type ComentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
    /**
     * Filter which Comentario to delete.
     */
    where: ComentarioWhereUniqueInput
  }

  /**
   * Comentario deleteMany
   */
  export type ComentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comentarios to delete
     */
    where?: ComentarioWhereInput
  }

  /**
   * Comentario without action
   */
  export type ComentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comentario
     */
    select?: ComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComentarioInclude<ExtArgs> | null
  }


  /**
   * Model Prerequisito
   */

  export type AggregatePrerequisito = {
    _count: PrerequisitoCountAggregateOutputType | null
    _avg: PrerequisitoAvgAggregateOutputType | null
    _sum: PrerequisitoSumAggregateOutputType | null
    _min: PrerequisitoMinAggregateOutputType | null
    _max: PrerequisitoMaxAggregateOutputType | null
  }

  export type PrerequisitoAvgAggregateOutputType = {
    id: number | null
    fkEstudiante: number | null
  }

  export type PrerequisitoSumAggregateOutputType = {
    id: number | null
    fkEstudiante: number | null
  }

  export type PrerequisitoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    cumplido: boolean | null
    archivoUrl: string | null
    fkEstudiante: number | null
  }

  export type PrerequisitoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    cumplido: boolean | null
    archivoUrl: string | null
    fkEstudiante: number | null
  }

  export type PrerequisitoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    cumplido: number
    archivoUrl: number
    fkEstudiante: number
    _all: number
  }


  export type PrerequisitoAvgAggregateInputType = {
    id?: true
    fkEstudiante?: true
  }

  export type PrerequisitoSumAggregateInputType = {
    id?: true
    fkEstudiante?: true
  }

  export type PrerequisitoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    cumplido?: true
    archivoUrl?: true
    fkEstudiante?: true
  }

  export type PrerequisitoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    cumplido?: true
    archivoUrl?: true
    fkEstudiante?: true
  }

  export type PrerequisitoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    cumplido?: true
    archivoUrl?: true
    fkEstudiante?: true
    _all?: true
  }

  export type PrerequisitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisito to aggregate.
     */
    where?: PrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisitos to fetch.
     */
    orderBy?: PrerequisitoOrderByWithRelationInput | PrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prerequisitos
    **/
    _count?: true | PrerequisitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrerequisitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrerequisitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrerequisitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrerequisitoMaxAggregateInputType
  }

  export type GetPrerequisitoAggregateType<T extends PrerequisitoAggregateArgs> = {
        [P in keyof T & keyof AggregatePrerequisito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrerequisito[P]>
      : GetScalarType<T[P], AggregatePrerequisito[P]>
  }




  export type PrerequisitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrerequisitoWhereInput
    orderBy?: PrerequisitoOrderByWithAggregationInput | PrerequisitoOrderByWithAggregationInput[]
    by: PrerequisitoScalarFieldEnum[] | PrerequisitoScalarFieldEnum
    having?: PrerequisitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrerequisitoCountAggregateInputType | true
    _avg?: PrerequisitoAvgAggregateInputType
    _sum?: PrerequisitoSumAggregateInputType
    _min?: PrerequisitoMinAggregateInputType
    _max?: PrerequisitoMaxAggregateInputType
  }

  export type PrerequisitoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    cumplido: boolean
    archivoUrl: string | null
    fkEstudiante: number
    _count: PrerequisitoCountAggregateOutputType | null
    _avg: PrerequisitoAvgAggregateOutputType | null
    _sum: PrerequisitoSumAggregateOutputType | null
    _min: PrerequisitoMinAggregateOutputType | null
    _max: PrerequisitoMaxAggregateOutputType | null
  }

  type GetPrerequisitoGroupByPayload<T extends PrerequisitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrerequisitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrerequisitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrerequisitoGroupByOutputType[P]>
            : GetScalarType<T[P], PrerequisitoGroupByOutputType[P]>
        }
      >
    >


  export type PrerequisitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    cumplido?: boolean
    archivoUrl?: boolean
    fkEstudiante?: boolean
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prerequisito"]>


  export type PrerequisitoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    cumplido?: boolean
    archivoUrl?: boolean
    fkEstudiante?: boolean
  }

  export type PrerequisitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PrerequisitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prerequisito"
    objects: {
      estudiante: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      cumplido: boolean
      archivoUrl: string | null
      fkEstudiante: number
    }, ExtArgs["result"]["prerequisito"]>
    composites: {}
  }

  type PrerequisitoGetPayload<S extends boolean | null | undefined | PrerequisitoDefaultArgs> = $Result.GetResult<Prisma.$PrerequisitoPayload, S>

  type PrerequisitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrerequisitoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrerequisitoCountAggregateInputType | true
    }

  export interface PrerequisitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prerequisito'], meta: { name: 'Prerequisito' } }
    /**
     * Find zero or one Prerequisito that matches the filter.
     * @param {PrerequisitoFindUniqueArgs} args - Arguments to find a Prerequisito
     * @example
     * // Get one Prerequisito
     * const prerequisito = await prisma.prerequisito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrerequisitoFindUniqueArgs>(args: SelectSubset<T, PrerequisitoFindUniqueArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prerequisito that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrerequisitoFindUniqueOrThrowArgs} args - Arguments to find a Prerequisito
     * @example
     * // Get one Prerequisito
     * const prerequisito = await prisma.prerequisito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrerequisitoFindUniqueOrThrowArgs>(args: SelectSubset<T, PrerequisitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prerequisito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoFindFirstArgs} args - Arguments to find a Prerequisito
     * @example
     * // Get one Prerequisito
     * const prerequisito = await prisma.prerequisito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrerequisitoFindFirstArgs>(args?: SelectSubset<T, PrerequisitoFindFirstArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prerequisito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoFindFirstOrThrowArgs} args - Arguments to find a Prerequisito
     * @example
     * // Get one Prerequisito
     * const prerequisito = await prisma.prerequisito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrerequisitoFindFirstOrThrowArgs>(args?: SelectSubset<T, PrerequisitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prerequisitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prerequisitos
     * const prerequisitos = await prisma.prerequisito.findMany()
     * 
     * // Get first 10 Prerequisitos
     * const prerequisitos = await prisma.prerequisito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prerequisitoWithIdOnly = await prisma.prerequisito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrerequisitoFindManyArgs>(args?: SelectSubset<T, PrerequisitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prerequisito.
     * @param {PrerequisitoCreateArgs} args - Arguments to create a Prerequisito.
     * @example
     * // Create one Prerequisito
     * const Prerequisito = await prisma.prerequisito.create({
     *   data: {
     *     // ... data to create a Prerequisito
     *   }
     * })
     * 
     */
    create<T extends PrerequisitoCreateArgs>(args: SelectSubset<T, PrerequisitoCreateArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prerequisitos.
     * @param {PrerequisitoCreateManyArgs} args - Arguments to create many Prerequisitos.
     * @example
     * // Create many Prerequisitos
     * const prerequisito = await prisma.prerequisito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrerequisitoCreateManyArgs>(args?: SelectSubset<T, PrerequisitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prerequisito.
     * @param {PrerequisitoDeleteArgs} args - Arguments to delete one Prerequisito.
     * @example
     * // Delete one Prerequisito
     * const Prerequisito = await prisma.prerequisito.delete({
     *   where: {
     *     // ... filter to delete one Prerequisito
     *   }
     * })
     * 
     */
    delete<T extends PrerequisitoDeleteArgs>(args: SelectSubset<T, PrerequisitoDeleteArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prerequisito.
     * @param {PrerequisitoUpdateArgs} args - Arguments to update one Prerequisito.
     * @example
     * // Update one Prerequisito
     * const prerequisito = await prisma.prerequisito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrerequisitoUpdateArgs>(args: SelectSubset<T, PrerequisitoUpdateArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prerequisitos.
     * @param {PrerequisitoDeleteManyArgs} args - Arguments to filter Prerequisitos to delete.
     * @example
     * // Delete a few Prerequisitos
     * const { count } = await prisma.prerequisito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrerequisitoDeleteManyArgs>(args?: SelectSubset<T, PrerequisitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prerequisitos
     * const prerequisito = await prisma.prerequisito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrerequisitoUpdateManyArgs>(args: SelectSubset<T, PrerequisitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prerequisito.
     * @param {PrerequisitoUpsertArgs} args - Arguments to update or create a Prerequisito.
     * @example
     * // Update or create a Prerequisito
     * const prerequisito = await prisma.prerequisito.upsert({
     *   create: {
     *     // ... data to create a Prerequisito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prerequisito we want to update
     *   }
     * })
     */
    upsert<T extends PrerequisitoUpsertArgs>(args: SelectSubset<T, PrerequisitoUpsertArgs<ExtArgs>>): Prisma__PrerequisitoClient<$Result.GetResult<Prisma.$PrerequisitoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prerequisitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoCountArgs} args - Arguments to filter Prerequisitos to count.
     * @example
     * // Count the number of Prerequisitos
     * const count = await prisma.prerequisito.count({
     *   where: {
     *     // ... the filter for the Prerequisitos we want to count
     *   }
     * })
    **/
    count<T extends PrerequisitoCountArgs>(
      args?: Subset<T, PrerequisitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrerequisitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrerequisitoAggregateArgs>(args: Subset<T, PrerequisitoAggregateArgs>): Prisma.PrismaPromise<GetPrerequisitoAggregateType<T>>

    /**
     * Group by Prerequisito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrerequisitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrerequisitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrerequisitoGroupByArgs['orderBy'] }
        : { orderBy?: PrerequisitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrerequisitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrerequisitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prerequisito model
   */
  readonly fields: PrerequisitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prerequisito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrerequisitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prerequisito model
   */ 
  interface PrerequisitoFieldRefs {
    readonly id: FieldRef<"Prerequisito", 'Int'>
    readonly nombre: FieldRef<"Prerequisito", 'String'>
    readonly descripcion: FieldRef<"Prerequisito", 'String'>
    readonly cumplido: FieldRef<"Prerequisito", 'Boolean'>
    readonly archivoUrl: FieldRef<"Prerequisito", 'String'>
    readonly fkEstudiante: FieldRef<"Prerequisito", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Prerequisito findUnique
   */
  export type PrerequisitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisito to fetch.
     */
    where: PrerequisitoWhereUniqueInput
  }

  /**
   * Prerequisito findUniqueOrThrow
   */
  export type PrerequisitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisito to fetch.
     */
    where: PrerequisitoWhereUniqueInput
  }

  /**
   * Prerequisito findFirst
   */
  export type PrerequisitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisito to fetch.
     */
    where?: PrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisitos to fetch.
     */
    orderBy?: PrerequisitoOrderByWithRelationInput | PrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisitos.
     */
    cursor?: PrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisitos.
     */
    distinct?: PrerequisitoScalarFieldEnum | PrerequisitoScalarFieldEnum[]
  }

  /**
   * Prerequisito findFirstOrThrow
   */
  export type PrerequisitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisito to fetch.
     */
    where?: PrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisitos to fetch.
     */
    orderBy?: PrerequisitoOrderByWithRelationInput | PrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prerequisitos.
     */
    cursor?: PrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prerequisitos.
     */
    distinct?: PrerequisitoScalarFieldEnum | PrerequisitoScalarFieldEnum[]
  }

  /**
   * Prerequisito findMany
   */
  export type PrerequisitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter, which Prerequisitos to fetch.
     */
    where?: PrerequisitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prerequisitos to fetch.
     */
    orderBy?: PrerequisitoOrderByWithRelationInput | PrerequisitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prerequisitos.
     */
    cursor?: PrerequisitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prerequisitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prerequisitos.
     */
    skip?: number
    distinct?: PrerequisitoScalarFieldEnum | PrerequisitoScalarFieldEnum[]
  }

  /**
   * Prerequisito create
   */
  export type PrerequisitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to create a Prerequisito.
     */
    data: XOR<PrerequisitoCreateInput, PrerequisitoUncheckedCreateInput>
  }

  /**
   * Prerequisito createMany
   */
  export type PrerequisitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prerequisitos.
     */
    data: PrerequisitoCreateManyInput | PrerequisitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prerequisito update
   */
  export type PrerequisitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * The data needed to update a Prerequisito.
     */
    data: XOR<PrerequisitoUpdateInput, PrerequisitoUncheckedUpdateInput>
    /**
     * Choose, which Prerequisito to update.
     */
    where: PrerequisitoWhereUniqueInput
  }

  /**
   * Prerequisito updateMany
   */
  export type PrerequisitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prerequisitos.
     */
    data: XOR<PrerequisitoUpdateManyMutationInput, PrerequisitoUncheckedUpdateManyInput>
    /**
     * Filter which Prerequisitos to update
     */
    where?: PrerequisitoWhereInput
  }

  /**
   * Prerequisito upsert
   */
  export type PrerequisitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * The filter to search for the Prerequisito to update in case it exists.
     */
    where: PrerequisitoWhereUniqueInput
    /**
     * In case the Prerequisito found by the `where` argument doesn't exist, create a new Prerequisito with this data.
     */
    create: XOR<PrerequisitoCreateInput, PrerequisitoUncheckedCreateInput>
    /**
     * In case the Prerequisito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrerequisitoUpdateInput, PrerequisitoUncheckedUpdateInput>
  }

  /**
   * Prerequisito delete
   */
  export type PrerequisitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
    /**
     * Filter which Prerequisito to delete.
     */
    where: PrerequisitoWhereUniqueInput
  }

  /**
   * Prerequisito deleteMany
   */
  export type PrerequisitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prerequisitos to delete
     */
    where?: PrerequisitoWhereInput
  }

  /**
   * Prerequisito without action
   */
  export type PrerequisitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prerequisito
     */
    select?: PrerequisitoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrerequisitoInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionAvgAggregateOutputType = {
    id: number | null
    usuariosId: number | null
  }

  export type NotificacionSumAggregateOutputType = {
    id: number | null
    usuariosId: number | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: number | null
    mensaje: string | null
    leido: boolean | null
    fechaCreacion: Date | null
    usuariosId: number | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: number | null
    mensaje: string | null
    leido: boolean | null
    fechaCreacion: Date | null
    usuariosId: number | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    mensaje: number
    leido: number
    fechaCreacion: number
    usuariosId: number
    _all: number
  }


  export type NotificacionAvgAggregateInputType = {
    id?: true
    usuariosId?: true
  }

  export type NotificacionSumAggregateInputType = {
    id?: true
    usuariosId?: true
  }

  export type NotificacionMinAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuariosId?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuariosId?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    mensaje?: true
    leido?: true
    fechaCreacion?: true
    usuariosId?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _avg?: NotificacionAvgAggregateInputType
    _sum?: NotificacionSumAggregateInputType
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: number
    mensaje: string
    leido: boolean
    fechaCreacion: Date
    usuariosId: number
    _count: NotificacionCountAggregateOutputType | null
    _avg: NotificacionAvgAggregateOutputType | null
    _sum: NotificacionSumAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mensaje?: boolean
    leido?: boolean
    fechaCreacion?: boolean
    usuariosId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>


  export type NotificacionSelectScalar = {
    id?: boolean
    mensaje?: boolean
    leido?: boolean
    fechaCreacion?: boolean
    usuariosId?: boolean
  }

  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mensaje: string
      leido: boolean
      fechaCreacion: Date
      usuariosId: number
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */ 
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'Int'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly leido: FieldRef<"Notificacion", 'Boolean'>
    readonly fechaCreacion: FieldRef<"Notificacion", 'DateTime'>
    readonly usuariosId: FieldRef<"Notificacion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model EntregableFinal
   */

  export type AggregateEntregableFinal = {
    _count: EntregableFinalCountAggregateOutputType | null
    _avg: EntregableFinalAvgAggregateOutputType | null
    _sum: EntregableFinalSumAggregateOutputType | null
    _min: EntregableFinalMinAggregateOutputType | null
    _max: EntregableFinalMaxAggregateOutputType | null
  }

  export type EntregableFinalAvgAggregateOutputType = {
    id: number | null
    propuestasId: number | null
  }

  export type EntregableFinalSumAggregateOutputType = {
    id: number | null
    propuestasId: number | null
  }

  export type EntregableFinalMinAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoEntregable | null
    urlArchivo: string | null
    fechaSubida: Date | null
    propuestasId: number | null
  }

  export type EntregableFinalMaxAggregateOutputType = {
    id: number | null
    tipo: $Enums.TipoEntregable | null
    urlArchivo: string | null
    fechaSubida: Date | null
    propuestasId: number | null
  }

  export type EntregableFinalCountAggregateOutputType = {
    id: number
    tipo: number
    urlArchivo: number
    fechaSubida: number
    propuestasId: number
    _all: number
  }


  export type EntregableFinalAvgAggregateInputType = {
    id?: true
    propuestasId?: true
  }

  export type EntregableFinalSumAggregateInputType = {
    id?: true
    propuestasId?: true
  }

  export type EntregableFinalMinAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
  }

  export type EntregableFinalMaxAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
  }

  export type EntregableFinalCountAggregateInputType = {
    id?: true
    tipo?: true
    urlArchivo?: true
    fechaSubida?: true
    propuestasId?: true
    _all?: true
  }

  export type EntregableFinalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntregableFinal to aggregate.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntregableFinals
    **/
    _count?: true | EntregableFinalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntregableFinalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntregableFinalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntregableFinalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntregableFinalMaxAggregateInputType
  }

  export type GetEntregableFinalAggregateType<T extends EntregableFinalAggregateArgs> = {
        [P in keyof T & keyof AggregateEntregableFinal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntregableFinal[P]>
      : GetScalarType<T[P], AggregateEntregableFinal[P]>
  }




  export type EntregableFinalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntregableFinalWhereInput
    orderBy?: EntregableFinalOrderByWithAggregationInput | EntregableFinalOrderByWithAggregationInput[]
    by: EntregableFinalScalarFieldEnum[] | EntregableFinalScalarFieldEnum
    having?: EntregableFinalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntregableFinalCountAggregateInputType | true
    _avg?: EntregableFinalAvgAggregateInputType
    _sum?: EntregableFinalSumAggregateInputType
    _min?: EntregableFinalMinAggregateInputType
    _max?: EntregableFinalMaxAggregateInputType
  }

  export type EntregableFinalGroupByOutputType = {
    id: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida: Date
    propuestasId: number
    _count: EntregableFinalCountAggregateOutputType | null
    _avg: EntregableFinalAvgAggregateOutputType | null
    _sum: EntregableFinalSumAggregateOutputType | null
    _min: EntregableFinalMinAggregateOutputType | null
    _max: EntregableFinalMaxAggregateOutputType | null
  }

  type GetEntregableFinalGroupByPayload<T extends EntregableFinalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntregableFinalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntregableFinalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntregableFinalGroupByOutputType[P]>
            : GetScalarType<T[P], EntregableFinalGroupByOutputType[P]>
        }
      >
    >


  export type EntregableFinalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    urlArchivo?: boolean
    fechaSubida?: boolean
    propuestasId?: boolean
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entregableFinal"]>


  export type EntregableFinalSelectScalar = {
    id?: boolean
    tipo?: boolean
    urlArchivo?: boolean
    fechaSubida?: boolean
    propuestasId?: boolean
  }

  export type EntregableFinalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }

  export type $EntregableFinalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntregableFinal"
    objects: {
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: $Enums.TipoEntregable
      urlArchivo: string
      fechaSubida: Date
      propuestasId: number
    }, ExtArgs["result"]["entregableFinal"]>
    composites: {}
  }

  type EntregableFinalGetPayload<S extends boolean | null | undefined | EntregableFinalDefaultArgs> = $Result.GetResult<Prisma.$EntregableFinalPayload, S>

  type EntregableFinalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EntregableFinalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EntregableFinalCountAggregateInputType | true
    }

  export interface EntregableFinalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntregableFinal'], meta: { name: 'EntregableFinal' } }
    /**
     * Find zero or one EntregableFinal that matches the filter.
     * @param {EntregableFinalFindUniqueArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntregableFinalFindUniqueArgs>(args: SelectSubset<T, EntregableFinalFindUniqueArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EntregableFinal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EntregableFinalFindUniqueOrThrowArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntregableFinalFindUniqueOrThrowArgs>(args: SelectSubset<T, EntregableFinalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EntregableFinal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindFirstArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntregableFinalFindFirstArgs>(args?: SelectSubset<T, EntregableFinalFindFirstArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EntregableFinal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindFirstOrThrowArgs} args - Arguments to find a EntregableFinal
     * @example
     * // Get one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntregableFinalFindFirstOrThrowArgs>(args?: SelectSubset<T, EntregableFinalFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EntregableFinals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntregableFinals
     * const entregableFinals = await prisma.entregableFinal.findMany()
     * 
     * // Get first 10 EntregableFinals
     * const entregableFinals = await prisma.entregableFinal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entregableFinalWithIdOnly = await prisma.entregableFinal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntregableFinalFindManyArgs>(args?: SelectSubset<T, EntregableFinalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EntregableFinal.
     * @param {EntregableFinalCreateArgs} args - Arguments to create a EntregableFinal.
     * @example
     * // Create one EntregableFinal
     * const EntregableFinal = await prisma.entregableFinal.create({
     *   data: {
     *     // ... data to create a EntregableFinal
     *   }
     * })
     * 
     */
    create<T extends EntregableFinalCreateArgs>(args: SelectSubset<T, EntregableFinalCreateArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EntregableFinals.
     * @param {EntregableFinalCreateManyArgs} args - Arguments to create many EntregableFinals.
     * @example
     * // Create many EntregableFinals
     * const entregableFinal = await prisma.entregableFinal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntregableFinalCreateManyArgs>(args?: SelectSubset<T, EntregableFinalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EntregableFinal.
     * @param {EntregableFinalDeleteArgs} args - Arguments to delete one EntregableFinal.
     * @example
     * // Delete one EntregableFinal
     * const EntregableFinal = await prisma.entregableFinal.delete({
     *   where: {
     *     // ... filter to delete one EntregableFinal
     *   }
     * })
     * 
     */
    delete<T extends EntregableFinalDeleteArgs>(args: SelectSubset<T, EntregableFinalDeleteArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EntregableFinal.
     * @param {EntregableFinalUpdateArgs} args - Arguments to update one EntregableFinal.
     * @example
     * // Update one EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntregableFinalUpdateArgs>(args: SelectSubset<T, EntregableFinalUpdateArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EntregableFinals.
     * @param {EntregableFinalDeleteManyArgs} args - Arguments to filter EntregableFinals to delete.
     * @example
     * // Delete a few EntregableFinals
     * const { count } = await prisma.entregableFinal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntregableFinalDeleteManyArgs>(args?: SelectSubset<T, EntregableFinalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntregableFinals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntregableFinals
     * const entregableFinal = await prisma.entregableFinal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntregableFinalUpdateManyArgs>(args: SelectSubset<T, EntregableFinalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EntregableFinal.
     * @param {EntregableFinalUpsertArgs} args - Arguments to update or create a EntregableFinal.
     * @example
     * // Update or create a EntregableFinal
     * const entregableFinal = await prisma.entregableFinal.upsert({
     *   create: {
     *     // ... data to create a EntregableFinal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntregableFinal we want to update
     *   }
     * })
     */
    upsert<T extends EntregableFinalUpsertArgs>(args: SelectSubset<T, EntregableFinalUpsertArgs<ExtArgs>>): Prisma__EntregableFinalClient<$Result.GetResult<Prisma.$EntregableFinalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EntregableFinals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalCountArgs} args - Arguments to filter EntregableFinals to count.
     * @example
     * // Count the number of EntregableFinals
     * const count = await prisma.entregableFinal.count({
     *   where: {
     *     // ... the filter for the EntregableFinals we want to count
     *   }
     * })
    **/
    count<T extends EntregableFinalCountArgs>(
      args?: Subset<T, EntregableFinalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntregableFinalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntregableFinal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntregableFinalAggregateArgs>(args: Subset<T, EntregableFinalAggregateArgs>): Prisma.PrismaPromise<GetEntregableFinalAggregateType<T>>

    /**
     * Group by EntregableFinal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntregableFinalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntregableFinalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntregableFinalGroupByArgs['orderBy'] }
        : { orderBy?: EntregableFinalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntregableFinalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntregableFinalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntregableFinal model
   */
  readonly fields: EntregableFinalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntregableFinal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntregableFinalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntregableFinal model
   */ 
  interface EntregableFinalFieldRefs {
    readonly id: FieldRef<"EntregableFinal", 'Int'>
    readonly tipo: FieldRef<"EntregableFinal", 'TipoEntregable'>
    readonly urlArchivo: FieldRef<"EntregableFinal", 'String'>
    readonly fechaSubida: FieldRef<"EntregableFinal", 'DateTime'>
    readonly propuestasId: FieldRef<"EntregableFinal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EntregableFinal findUnique
   */
  export type EntregableFinalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal findUniqueOrThrow
   */
  export type EntregableFinalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal findFirst
   */
  export type EntregableFinalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntregableFinals.
     */
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal findFirstOrThrow
   */
  export type EntregableFinalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinal to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntregableFinals.
     */
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal findMany
   */
  export type EntregableFinalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter, which EntregableFinals to fetch.
     */
    where?: EntregableFinalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntregableFinals to fetch.
     */
    orderBy?: EntregableFinalOrderByWithRelationInput | EntregableFinalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntregableFinals.
     */
    cursor?: EntregableFinalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntregableFinals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntregableFinals.
     */
    skip?: number
    distinct?: EntregableFinalScalarFieldEnum | EntregableFinalScalarFieldEnum[]
  }

  /**
   * EntregableFinal create
   */
  export type EntregableFinalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The data needed to create a EntregableFinal.
     */
    data: XOR<EntregableFinalCreateInput, EntregableFinalUncheckedCreateInput>
  }

  /**
   * EntregableFinal createMany
   */
  export type EntregableFinalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntregableFinals.
     */
    data: EntregableFinalCreateManyInput | EntregableFinalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntregableFinal update
   */
  export type EntregableFinalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The data needed to update a EntregableFinal.
     */
    data: XOR<EntregableFinalUpdateInput, EntregableFinalUncheckedUpdateInput>
    /**
     * Choose, which EntregableFinal to update.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal updateMany
   */
  export type EntregableFinalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntregableFinals.
     */
    data: XOR<EntregableFinalUpdateManyMutationInput, EntregableFinalUncheckedUpdateManyInput>
    /**
     * Filter which EntregableFinals to update
     */
    where?: EntregableFinalWhereInput
  }

  /**
   * EntregableFinal upsert
   */
  export type EntregableFinalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * The filter to search for the EntregableFinal to update in case it exists.
     */
    where: EntregableFinalWhereUniqueInput
    /**
     * In case the EntregableFinal found by the `where` argument doesn't exist, create a new EntregableFinal with this data.
     */
    create: XOR<EntregableFinalCreateInput, EntregableFinalUncheckedCreateInput>
    /**
     * In case the EntregableFinal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntregableFinalUpdateInput, EntregableFinalUncheckedUpdateInput>
  }

  /**
   * EntregableFinal delete
   */
  export type EntregableFinalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
    /**
     * Filter which EntregableFinal to delete.
     */
    where: EntregableFinalWhereUniqueInput
  }

  /**
   * EntregableFinal deleteMany
   */
  export type EntregableFinalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntregableFinals to delete
     */
    where?: EntregableFinalWhereInput
  }

  /**
   * EntregableFinal without action
   */
  export type EntregableFinalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntregableFinal
     */
    select?: EntregableFinalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntregableFinalInclude<ExtArgs> | null
  }


  /**
   * Model Comite
   */

  export type AggregateComite = {
    _count: ComiteCountAggregateOutputType | null
    _avg: ComiteAvgAggregateOutputType | null
    _sum: ComiteSumAggregateOutputType | null
    _min: ComiteMinAggregateOutputType | null
    _max: ComiteMaxAggregateOutputType | null
  }

  export type ComiteAvgAggregateOutputType = {
    usuariosId: number | null
    propuestasId: number | null
    calificacion: Decimal | null
  }

  export type ComiteSumAggregateOutputType = {
    usuariosId: number | null
    propuestasId: number | null
    calificacion: Decimal | null
  }

  export type ComiteMinAggregateOutputType = {
    usuariosId: number | null
    propuestasId: number | null
    rol: $Enums.RolComite | null
    calificacion: Decimal | null
    fechaAsignada: Date | null
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
  }

  export type ComiteMaxAggregateOutputType = {
    usuariosId: number | null
    propuestasId: number | null
    rol: $Enums.RolComite | null
    calificacion: Decimal | null
    fechaAsignada: Date | null
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
  }

  export type ComiteCountAggregateOutputType = {
    usuariosId: number
    propuestasId: number
    rol: number
    calificacion: number
    fechaAsignada: number
    fechaDefensa: number
    resultadoDefensa: number
    _all: number
  }


  export type ComiteAvgAggregateInputType = {
    usuariosId?: true
    propuestasId?: true
    calificacion?: true
  }

  export type ComiteSumAggregateInputType = {
    usuariosId?: true
    propuestasId?: true
    calificacion?: true
  }

  export type ComiteMinAggregateInputType = {
    usuariosId?: true
    propuestasId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
    fechaDefensa?: true
    resultadoDefensa?: true
  }

  export type ComiteMaxAggregateInputType = {
    usuariosId?: true
    propuestasId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
    fechaDefensa?: true
    resultadoDefensa?: true
  }

  export type ComiteCountAggregateInputType = {
    usuariosId?: true
    propuestasId?: true
    rol?: true
    calificacion?: true
    fechaAsignada?: true
    fechaDefensa?: true
    resultadoDefensa?: true
    _all?: true
  }

  export type ComiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comite to aggregate.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comites
    **/
    _count?: true | ComiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComiteMaxAggregateInputType
  }

  export type GetComiteAggregateType<T extends ComiteAggregateArgs> = {
        [P in keyof T & keyof AggregateComite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComite[P]>
      : GetScalarType<T[P], AggregateComite[P]>
  }




  export type ComiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComiteWhereInput
    orderBy?: ComiteOrderByWithAggregationInput | ComiteOrderByWithAggregationInput[]
    by: ComiteScalarFieldEnum[] | ComiteScalarFieldEnum
    having?: ComiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComiteCountAggregateInputType | true
    _avg?: ComiteAvgAggregateInputType
    _sum?: ComiteSumAggregateInputType
    _min?: ComiteMinAggregateInputType
    _max?: ComiteMaxAggregateInputType
  }

  export type ComiteGroupByOutputType = {
    usuariosId: number
    propuestasId: number
    rol: $Enums.RolComite
    calificacion: Decimal | null
    fechaAsignada: Date | null
    fechaDefensa: Date | null
    resultadoDefensa: $Enums.ResultadoDefensa | null
    _count: ComiteCountAggregateOutputType | null
    _avg: ComiteAvgAggregateOutputType | null
    _sum: ComiteSumAggregateOutputType | null
    _min: ComiteMinAggregateOutputType | null
    _max: ComiteMaxAggregateOutputType | null
  }

  type GetComiteGroupByPayload<T extends ComiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComiteGroupByOutputType[P]>
            : GetScalarType<T[P], ComiteGroupByOutputType[P]>
        }
      >
    >


  export type ComiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuariosId?: boolean
    propuestasId?: boolean
    rol?: boolean
    calificacion?: boolean
    fechaAsignada?: boolean
    fechaDefensa?: boolean
    resultadoDefensa?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comite"]>


  export type ComiteSelectScalar = {
    usuariosId?: boolean
    propuestasId?: boolean
    rol?: boolean
    calificacion?: boolean
    fechaAsignada?: boolean
    fechaDefensa?: boolean
    resultadoDefensa?: boolean
  }

  export type ComiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    propuesta?: boolean | PropuestaDefaultArgs<ExtArgs>
  }

  export type $ComitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comite"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      propuesta: Prisma.$PropuestaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      usuariosId: number
      propuestasId: number
      rol: $Enums.RolComite
      calificacion: Prisma.Decimal | null
      fechaAsignada: Date | null
      fechaDefensa: Date | null
      resultadoDefensa: $Enums.ResultadoDefensa | null
    }, ExtArgs["result"]["comite"]>
    composites: {}
  }

  type ComiteGetPayload<S extends boolean | null | undefined | ComiteDefaultArgs> = $Result.GetResult<Prisma.$ComitePayload, S>

  type ComiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComiteCountAggregateInputType | true
    }

  export interface ComiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comite'], meta: { name: 'Comite' } }
    /**
     * Find zero or one Comite that matches the filter.
     * @param {ComiteFindUniqueArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComiteFindUniqueArgs>(args: SelectSubset<T, ComiteFindUniqueArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComiteFindUniqueOrThrowArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComiteFindUniqueOrThrowArgs>(args: SelectSubset<T, ComiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindFirstArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComiteFindFirstArgs>(args?: SelectSubset<T, ComiteFindFirstArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindFirstOrThrowArgs} args - Arguments to find a Comite
     * @example
     * // Get one Comite
     * const comite = await prisma.comite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComiteFindFirstOrThrowArgs>(args?: SelectSubset<T, ComiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comites
     * const comites = await prisma.comite.findMany()
     * 
     * // Get first 10 Comites
     * const comites = await prisma.comite.findMany({ take: 10 })
     * 
     * // Only select the `usuariosId`
     * const comiteWithUsuariosIdOnly = await prisma.comite.findMany({ select: { usuariosId: true } })
     * 
     */
    findMany<T extends ComiteFindManyArgs>(args?: SelectSubset<T, ComiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comite.
     * @param {ComiteCreateArgs} args - Arguments to create a Comite.
     * @example
     * // Create one Comite
     * const Comite = await prisma.comite.create({
     *   data: {
     *     // ... data to create a Comite
     *   }
     * })
     * 
     */
    create<T extends ComiteCreateArgs>(args: SelectSubset<T, ComiteCreateArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comites.
     * @param {ComiteCreateManyArgs} args - Arguments to create many Comites.
     * @example
     * // Create many Comites
     * const comite = await prisma.comite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComiteCreateManyArgs>(args?: SelectSubset<T, ComiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comite.
     * @param {ComiteDeleteArgs} args - Arguments to delete one Comite.
     * @example
     * // Delete one Comite
     * const Comite = await prisma.comite.delete({
     *   where: {
     *     // ... filter to delete one Comite
     *   }
     * })
     * 
     */
    delete<T extends ComiteDeleteArgs>(args: SelectSubset<T, ComiteDeleteArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comite.
     * @param {ComiteUpdateArgs} args - Arguments to update one Comite.
     * @example
     * // Update one Comite
     * const comite = await prisma.comite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComiteUpdateArgs>(args: SelectSubset<T, ComiteUpdateArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comites.
     * @param {ComiteDeleteManyArgs} args - Arguments to filter Comites to delete.
     * @example
     * // Delete a few Comites
     * const { count } = await prisma.comite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComiteDeleteManyArgs>(args?: SelectSubset<T, ComiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comites
     * const comite = await prisma.comite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComiteUpdateManyArgs>(args: SelectSubset<T, ComiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comite.
     * @param {ComiteUpsertArgs} args - Arguments to update or create a Comite.
     * @example
     * // Update or create a Comite
     * const comite = await prisma.comite.upsert({
     *   create: {
     *     // ... data to create a Comite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comite we want to update
     *   }
     * })
     */
    upsert<T extends ComiteUpsertArgs>(args: SelectSubset<T, ComiteUpsertArgs<ExtArgs>>): Prisma__ComiteClient<$Result.GetResult<Prisma.$ComitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteCountArgs} args - Arguments to filter Comites to count.
     * @example
     * // Count the number of Comites
     * const count = await prisma.comite.count({
     *   where: {
     *     // ... the filter for the Comites we want to count
     *   }
     * })
    **/
    count<T extends ComiteCountArgs>(
      args?: Subset<T, ComiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComiteAggregateArgs>(args: Subset<T, ComiteAggregateArgs>): Prisma.PrismaPromise<GetComiteAggregateType<T>>

    /**
     * Group by Comite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComiteGroupByArgs['orderBy'] }
        : { orderBy?: ComiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comite model
   */
  readonly fields: ComiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    propuesta<T extends PropuestaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropuestaDefaultArgs<ExtArgs>>): Prisma__PropuestaClient<$Result.GetResult<Prisma.$PropuestaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comite model
   */ 
  interface ComiteFieldRefs {
    readonly usuariosId: FieldRef<"Comite", 'Int'>
    readonly propuestasId: FieldRef<"Comite", 'Int'>
    readonly rol: FieldRef<"Comite", 'RolComite'>
    readonly calificacion: FieldRef<"Comite", 'Decimal'>
    readonly fechaAsignada: FieldRef<"Comite", 'DateTime'>
    readonly fechaDefensa: FieldRef<"Comite", 'DateTime'>
    readonly resultadoDefensa: FieldRef<"Comite", 'ResultadoDefensa'>
  }
    

  // Custom InputTypes
  /**
   * Comite findUnique
   */
  export type ComiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite findUniqueOrThrow
   */
  export type ComiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite findFirst
   */
  export type ComiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comites.
     */
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite findFirstOrThrow
   */
  export type ComiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comite to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comites.
     */
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite findMany
   */
  export type ComiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter, which Comites to fetch.
     */
    where?: ComiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comites to fetch.
     */
    orderBy?: ComiteOrderByWithRelationInput | ComiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comites.
     */
    cursor?: ComiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comites.
     */
    skip?: number
    distinct?: ComiteScalarFieldEnum | ComiteScalarFieldEnum[]
  }

  /**
   * Comite create
   */
  export type ComiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Comite.
     */
    data: XOR<ComiteCreateInput, ComiteUncheckedCreateInput>
  }

  /**
   * Comite createMany
   */
  export type ComiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comites.
     */
    data: ComiteCreateManyInput | ComiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comite update
   */
  export type ComiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Comite.
     */
    data: XOR<ComiteUpdateInput, ComiteUncheckedUpdateInput>
    /**
     * Choose, which Comite to update.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite updateMany
   */
  export type ComiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comites.
     */
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyInput>
    /**
     * Filter which Comites to update
     */
    where?: ComiteWhereInput
  }

  /**
   * Comite upsert
   */
  export type ComiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Comite to update in case it exists.
     */
    where: ComiteWhereUniqueInput
    /**
     * In case the Comite found by the `where` argument doesn't exist, create a new Comite with this data.
     */
    create: XOR<ComiteCreateInput, ComiteUncheckedCreateInput>
    /**
     * In case the Comite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComiteUpdateInput, ComiteUncheckedUpdateInput>
  }

  /**
   * Comite delete
   */
  export type ComiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
    /**
     * Filter which Comite to delete.
     */
    where: ComiteWhereUniqueInput
  }

  /**
   * Comite deleteMany
   */
  export type ComiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comites to delete
     */
    where?: ComiteWhereInput
  }

  /**
   * Comite without action
   */
  export type ComiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comite
     */
    select?: ComiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComiteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    cedula: 'cedula',
    nombres: 'nombres',
    apellidos: 'apellidos',
    correoInstitucional: 'correoInstitucional',
    clave: 'clave',
    rol: 'rol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const PropuestaScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    objetivos: 'objetivos',
    problematica: 'problematica',
    areaInvestigacion: 'areaInvestigacion',
    alcance: 'alcance',
    archivoUrl: 'archivoUrl',
    fechaPublicacion: 'fechaPublicacion',
    estado: 'estado',
    fkEstudiante: 'fkEstudiante',
    aprobado: 'aprobado'
  };

  export type PropuestaScalarFieldEnum = (typeof PropuestaScalarFieldEnum)[keyof typeof PropuestaScalarFieldEnum]


  export const ActividadScalarFieldEnum: {
    idActividades: 'idActividades',
    nombre: 'nombre',
    descripcion: 'descripcion',
    propuestasId: 'propuestasId',
    usuariosId: 'usuariosId'
  };

  export type ActividadScalarFieldEnum = (typeof ActividadScalarFieldEnum)[keyof typeof ActividadScalarFieldEnum]


  export const EvidenciaScalarFieldEnum: {
    id: 'id',
    semana: 'semana',
    contenido: 'contenido',
    archivoUrl: 'archivoUrl',
    fechaEntrega: 'fechaEntrega',
    estado: 'estado',
    calificacion: 'calificacion',
    actividadesId: 'actividadesId'
  };

  export type EvidenciaScalarFieldEnum = (typeof EvidenciaScalarFieldEnum)[keyof typeof EvidenciaScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    idComentarios: 'idComentarios',
    descripcion: 'descripcion',
    evidenciaId: 'evidenciaId',
    usuariosId: 'usuariosId'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const PrerequisitoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    cumplido: 'cumplido',
    archivoUrl: 'archivoUrl',
    fkEstudiante: 'fkEstudiante'
  };

  export type PrerequisitoScalarFieldEnum = (typeof PrerequisitoScalarFieldEnum)[keyof typeof PrerequisitoScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    mensaje: 'mensaje',
    leido: 'leido',
    fechaCreacion: 'fechaCreacion',
    usuariosId: 'usuariosId'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const EntregableFinalScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    urlArchivo: 'urlArchivo',
    fechaSubida: 'fechaSubida',
    propuestasId: 'propuestasId'
  };

  export type EntregableFinalScalarFieldEnum = (typeof EntregableFinalScalarFieldEnum)[keyof typeof EntregableFinalScalarFieldEnum]


  export const ComiteScalarFieldEnum: {
    usuariosId: 'usuariosId',
    propuestasId: 'propuestasId',
    rol: 'rol',
    calificacion: 'calificacion',
    fechaAsignada: 'fechaAsignada',
    fechaDefensa: 'fechaDefensa',
    resultadoDefensa: 'resultadoDefensa'
  };

  export type ComiteScalarFieldEnum = (typeof ComiteScalarFieldEnum)[keyof typeof ComiteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'AreaInvestigacion'
   */
  export type EnumAreaInvestigacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AreaInvestigacion'>
    


  /**
   * Reference to a field of type 'EstadoPropuesta'
   */
  export type EnumEstadoPropuestaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPropuesta'>
    


  /**
   * Reference to a field of type 'EstadoEvidencia'
   */
  export type EnumEstadoEvidenciaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoEvidencia'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TipoEntregable'
   */
  export type EnumTipoEntregableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEntregable'>
    


  /**
   * Reference to a field of type 'RolComite'
   */
  export type EnumRolComiteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolComite'>
    


  /**
   * Reference to a field of type 'ResultadoDefensa'
   */
  export type EnumResultadoDefensaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultadoDefensa'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    cedula?: StringFilter<"Usuario"> | string
    nombres?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    correoInstitucional?: StringFilter<"Usuario"> | string
    clave?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    propuestas?: PropuestaListRelationFilter
    actividadesCreadas?: ActividadListRelationFilter
    comentarios?: ComentarioListRelationFilter
    notificaciones?: NotificacionListRelationFilter
    comiteAsignaciones?: ComiteListRelationFilter
    prerequisitos?: PrerequisitoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    clave?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    propuestas?: PropuestaOrderByRelationAggregateInput
    actividadesCreadas?: ActividadOrderByRelationAggregateInput
    comentarios?: ComentarioOrderByRelationAggregateInput
    notificaciones?: NotificacionOrderByRelationAggregateInput
    comiteAsignaciones?: ComiteOrderByRelationAggregateInput
    prerequisitos?: PrerequisitoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cedula?: string
    correoInstitucional?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombres?: StringFilter<"Usuario"> | string
    apellidos?: StringFilter<"Usuario"> | string
    clave?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    propuestas?: PropuestaListRelationFilter
    actividadesCreadas?: ActividadListRelationFilter
    comentarios?: ComentarioListRelationFilter
    notificaciones?: NotificacionListRelationFilter
    comiteAsignaciones?: ComiteListRelationFilter
    prerequisitos?: PrerequisitoListRelationFilter
  }, "id" | "cedula" | "correoInstitucional">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    clave?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    cedula?: StringWithAggregatesFilter<"Usuario"> | string
    nombres?: StringWithAggregatesFilter<"Usuario"> | string
    apellidos?: StringWithAggregatesFilter<"Usuario"> | string
    correoInstitucional?: StringWithAggregatesFilter<"Usuario"> | string
    clave?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type PropuestaWhereInput = {
    AND?: PropuestaWhereInput | PropuestaWhereInput[]
    OR?: PropuestaWhereInput[]
    NOT?: PropuestaWhereInput | PropuestaWhereInput[]
    id?: IntFilter<"Propuesta"> | number
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaInvestigacion?: EnumAreaInvestigacionFilter<"Propuesta"> | $Enums.AreaInvestigacion
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    aprobado?: IntNullableFilter<"Propuesta"> | number | null
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    actividades?: ActividadListRelationFilter
    comiteAsignaciones?: ComiteListRelationFilter
    entregablesFinales?: EntregableFinalListRelationFilter
  }

  export type PropuestaOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrderInput | SortOrder
    areaInvestigacion?: SortOrder
    alcance?: SortOrderInput | SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrderInput | SortOrder
    estudiante?: UsuarioOrderByWithRelationInput
    actividades?: ActividadOrderByRelationAggregateInput
    comiteAsignaciones?: ComiteOrderByRelationAggregateInput
    entregablesFinales?: EntregableFinalOrderByRelationAggregateInput
  }

  export type PropuestaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PropuestaWhereInput | PropuestaWhereInput[]
    OR?: PropuestaWhereInput[]
    NOT?: PropuestaWhereInput | PropuestaWhereInput[]
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaInvestigacion?: EnumAreaInvestigacionFilter<"Propuesta"> | $Enums.AreaInvestigacion
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    aprobado?: IntNullableFilter<"Propuesta"> | number | null
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    actividades?: ActividadListRelationFilter
    comiteAsignaciones?: ComiteListRelationFilter
    entregablesFinales?: EntregableFinalListRelationFilter
  }, "id">

  export type PropuestaOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrderInput | SortOrder
    areaInvestigacion?: SortOrder
    alcance?: SortOrderInput | SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrderInput | SortOrder
    _count?: PropuestaCountOrderByAggregateInput
    _avg?: PropuestaAvgOrderByAggregateInput
    _max?: PropuestaMaxOrderByAggregateInput
    _min?: PropuestaMinOrderByAggregateInput
    _sum?: PropuestaSumOrderByAggregateInput
  }

  export type PropuestaScalarWhereWithAggregatesInput = {
    AND?: PropuestaScalarWhereWithAggregatesInput | PropuestaScalarWhereWithAggregatesInput[]
    OR?: PropuestaScalarWhereWithAggregatesInput[]
    NOT?: PropuestaScalarWhereWithAggregatesInput | PropuestaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Propuesta"> | number
    titulo?: StringWithAggregatesFilter<"Propuesta"> | string
    objetivos?: StringWithAggregatesFilter<"Propuesta"> | string
    problematica?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    areaInvestigacion?: EnumAreaInvestigacionWithAggregatesFilter<"Propuesta"> | $Enums.AreaInvestigacion
    alcance?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableWithAggregatesFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeWithAggregatesFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaWithAggregatesFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntWithAggregatesFilter<"Propuesta"> | number
    aprobado?: IntNullableWithAggregatesFilter<"Propuesta"> | number | null
  }

  export type ActividadWhereInput = {
    AND?: ActividadWhereInput | ActividadWhereInput[]
    OR?: ActividadWhereInput[]
    NOT?: ActividadWhereInput | ActividadWhereInput[]
    idActividades?: IntFilter<"Actividad"> | number
    nombre?: StringNullableFilter<"Actividad"> | string | null
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestasId?: IntFilter<"Actividad"> | number
    usuariosId?: IntFilter<"Actividad"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }

  export type ActividadOrderByWithRelationInput = {
    idActividades?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
    propuesta?: PropuestaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    evidencias?: EvidenciaOrderByRelationAggregateInput
  }

  export type ActividadWhereUniqueInput = Prisma.AtLeast<{
    idActividades?: number
    AND?: ActividadWhereInput | ActividadWhereInput[]
    OR?: ActividadWhereInput[]
    NOT?: ActividadWhereInput | ActividadWhereInput[]
    nombre?: StringNullableFilter<"Actividad"> | string | null
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestasId?: IntFilter<"Actividad"> | number
    usuariosId?: IntFilter<"Actividad"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    evidencias?: EvidenciaListRelationFilter
  }, "idActividades">

  export type ActividadOrderByWithAggregationInput = {
    idActividades?: SortOrder
    nombre?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
    _count?: ActividadCountOrderByAggregateInput
    _avg?: ActividadAvgOrderByAggregateInput
    _max?: ActividadMaxOrderByAggregateInput
    _min?: ActividadMinOrderByAggregateInput
    _sum?: ActividadSumOrderByAggregateInput
  }

  export type ActividadScalarWhereWithAggregatesInput = {
    AND?: ActividadScalarWhereWithAggregatesInput | ActividadScalarWhereWithAggregatesInput[]
    OR?: ActividadScalarWhereWithAggregatesInput[]
    NOT?: ActividadScalarWhereWithAggregatesInput | ActividadScalarWhereWithAggregatesInput[]
    idActividades?: IntWithAggregatesFilter<"Actividad"> | number
    nombre?: StringNullableWithAggregatesFilter<"Actividad"> | string | null
    descripcion?: StringNullableWithAggregatesFilter<"Actividad"> | string | null
    propuestasId?: IntWithAggregatesFilter<"Actividad"> | number
    usuariosId?: IntWithAggregatesFilter<"Actividad"> | number
  }

  export type EvidenciaWhereInput = {
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    id?: IntFilter<"Evidencia"> | number
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFilter<"Evidencia"> | number
    actividad?: XOR<ActividadRelationFilter, ActividadWhereInput>
    comentarios?: ComentarioListRelationFilter
  }

  export type EvidenciaOrderByWithRelationInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    actividadesId?: SortOrder
    actividad?: ActividadOrderByWithRelationInput
    comentarios?: ComentarioOrderByRelationAggregateInput
  }

  export type EvidenciaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvidenciaWhereInput | EvidenciaWhereInput[]
    OR?: EvidenciaWhereInput[]
    NOT?: EvidenciaWhereInput | EvidenciaWhereInput[]
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFilter<"Evidencia"> | number
    actividad?: XOR<ActividadRelationFilter, ActividadWhereInput>
    comentarios?: ComentarioListRelationFilter
  }, "id">

  export type EvidenciaOrderByWithAggregationInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    actividadesId?: SortOrder
    _count?: EvidenciaCountOrderByAggregateInput
    _avg?: EvidenciaAvgOrderByAggregateInput
    _max?: EvidenciaMaxOrderByAggregateInput
    _min?: EvidenciaMinOrderByAggregateInput
    _sum?: EvidenciaSumOrderByAggregateInput
  }

  export type EvidenciaScalarWhereWithAggregatesInput = {
    AND?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    OR?: EvidenciaScalarWhereWithAggregatesInput[]
    NOT?: EvidenciaScalarWhereWithAggregatesInput | EvidenciaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evidencia"> | number
    semana?: IntWithAggregatesFilter<"Evidencia"> | number
    contenido?: StringWithAggregatesFilter<"Evidencia"> | string
    archivoUrl?: StringNullableWithAggregatesFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeWithAggregatesFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaWithAggregatesFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableWithAggregatesFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntWithAggregatesFilter<"Evidencia"> | number
  }

  export type ComentarioWhereInput = {
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    idComentarios?: IntFilter<"Comentario"> | number
    descripcion?: StringNullableFilter<"Comentario"> | string | null
    evidenciaId?: IntFilter<"Comentario"> | number
    usuariosId?: IntFilter<"Comentario"> | number
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type ComentarioOrderByWithRelationInput = {
    idComentarios?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
    evidencia?: EvidenciaOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ComentarioWhereUniqueInput = Prisma.AtLeast<{
    idComentarios?: number
    AND?: ComentarioWhereInput | ComentarioWhereInput[]
    OR?: ComentarioWhereInput[]
    NOT?: ComentarioWhereInput | ComentarioWhereInput[]
    descripcion?: StringNullableFilter<"Comentario"> | string | null
    evidenciaId?: IntFilter<"Comentario"> | number
    usuariosId?: IntFilter<"Comentario"> | number
    evidencia?: XOR<EvidenciaRelationFilter, EvidenciaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "idComentarios">

  export type ComentarioOrderByWithAggregationInput = {
    idComentarios?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
    _count?: ComentarioCountOrderByAggregateInput
    _avg?: ComentarioAvgOrderByAggregateInput
    _max?: ComentarioMaxOrderByAggregateInput
    _min?: ComentarioMinOrderByAggregateInput
    _sum?: ComentarioSumOrderByAggregateInput
  }

  export type ComentarioScalarWhereWithAggregatesInput = {
    AND?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    OR?: ComentarioScalarWhereWithAggregatesInput[]
    NOT?: ComentarioScalarWhereWithAggregatesInput | ComentarioScalarWhereWithAggregatesInput[]
    idComentarios?: IntWithAggregatesFilter<"Comentario"> | number
    descripcion?: StringNullableWithAggregatesFilter<"Comentario"> | string | null
    evidenciaId?: IntWithAggregatesFilter<"Comentario"> | number
    usuariosId?: IntWithAggregatesFilter<"Comentario"> | number
  }

  export type PrerequisitoWhereInput = {
    AND?: PrerequisitoWhereInput | PrerequisitoWhereInput[]
    OR?: PrerequisitoWhereInput[]
    NOT?: PrerequisitoWhereInput | PrerequisitoWhereInput[]
    id?: IntFilter<"Prerequisito"> | number
    nombre?: StringFilter<"Prerequisito"> | string
    descripcion?: StringNullableFilter<"Prerequisito"> | string | null
    cumplido?: BoolFilter<"Prerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"Prerequisito"> | string | null
    fkEstudiante?: IntFilter<"Prerequisito"> | number
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PrerequisitoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fkEstudiante?: SortOrder
    estudiante?: UsuarioOrderByWithRelationInput
  }

  export type PrerequisitoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrerequisitoWhereInput | PrerequisitoWhereInput[]
    OR?: PrerequisitoWhereInput[]
    NOT?: PrerequisitoWhereInput | PrerequisitoWhereInput[]
    nombre?: StringFilter<"Prerequisito"> | string
    descripcion?: StringNullableFilter<"Prerequisito"> | string | null
    cumplido?: BoolFilter<"Prerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"Prerequisito"> | string | null
    fkEstudiante?: IntFilter<"Prerequisito"> | number
    estudiante?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type PrerequisitoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrderInput | SortOrder
    fkEstudiante?: SortOrder
    _count?: PrerequisitoCountOrderByAggregateInput
    _avg?: PrerequisitoAvgOrderByAggregateInput
    _max?: PrerequisitoMaxOrderByAggregateInput
    _min?: PrerequisitoMinOrderByAggregateInput
    _sum?: PrerequisitoSumOrderByAggregateInput
  }

  export type PrerequisitoScalarWhereWithAggregatesInput = {
    AND?: PrerequisitoScalarWhereWithAggregatesInput | PrerequisitoScalarWhereWithAggregatesInput[]
    OR?: PrerequisitoScalarWhereWithAggregatesInput[]
    NOT?: PrerequisitoScalarWhereWithAggregatesInput | PrerequisitoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prerequisito"> | number
    nombre?: StringWithAggregatesFilter<"Prerequisito"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Prerequisito"> | string | null
    cumplido?: BoolWithAggregatesFilter<"Prerequisito"> | boolean
    archivoUrl?: StringNullableWithAggregatesFilter<"Prerequisito"> | string | null
    fkEstudiante?: IntWithAggregatesFilter<"Prerequisito"> | number
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuariosId?: IntFilter<"Notificacion"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuariosId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuariosId?: IntFilter<"Notificacion"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuariosId?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _avg?: NotificacionAvgOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
    _sum?: NotificacionSumOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notificacion"> | number
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    leido?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
    usuariosId?: IntWithAggregatesFilter<"Notificacion"> | number
  }

  export type EntregableFinalWhereInput = {
    AND?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    OR?: EntregableFinalWhereInput[]
    NOT?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    id?: IntFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }

  export type EntregableFinalOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
    propuesta?: PropuestaOrderByWithRelationInput
  }

  export type EntregableFinalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    OR?: EntregableFinalWhereInput[]
    NOT?: EntregableFinalWhereInput | EntregableFinalWhereInput[]
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }, "id">

  export type EntregableFinalOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
    _count?: EntregableFinalCountOrderByAggregateInput
    _avg?: EntregableFinalAvgOrderByAggregateInput
    _max?: EntregableFinalMaxOrderByAggregateInput
    _min?: EntregableFinalMinOrderByAggregateInput
    _sum?: EntregableFinalSumOrderByAggregateInput
  }

  export type EntregableFinalScalarWhereWithAggregatesInput = {
    AND?: EntregableFinalScalarWhereWithAggregatesInput | EntregableFinalScalarWhereWithAggregatesInput[]
    OR?: EntregableFinalScalarWhereWithAggregatesInput[]
    NOT?: EntregableFinalScalarWhereWithAggregatesInput | EntregableFinalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableWithAggregatesFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringWithAggregatesFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeWithAggregatesFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntWithAggregatesFilter<"EntregableFinal"> | number
  }

  export type ComiteWhereInput = {
    AND?: ComiteWhereInput | ComiteWhereInput[]
    OR?: ComiteWhereInput[]
    NOT?: ComiteWhereInput | ComiteWhereInput[]
    usuariosId?: IntFilter<"Comite"> | number
    propuestasId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
    fechaDefensa?: DateTimeNullableFilter<"Comite"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Comite"> | $Enums.ResultadoDefensa | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }

  export type ComiteOrderByWithRelationInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    fechaAsignada?: SortOrderInput | SortOrder
    fechaDefensa?: SortOrderInput | SortOrder
    resultadoDefensa?: SortOrderInput | SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    propuesta?: PropuestaOrderByWithRelationInput
  }

  export type ComiteWhereUniqueInput = Prisma.AtLeast<{
    usuariosId_propuestasId?: ComiteUsuariosIdPropuestasIdCompoundUniqueInput
    AND?: ComiteWhereInput | ComiteWhereInput[]
    OR?: ComiteWhereInput[]
    NOT?: ComiteWhereInput | ComiteWhereInput[]
    usuariosId?: IntFilter<"Comite"> | number
    propuestasId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
    fechaDefensa?: DateTimeNullableFilter<"Comite"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Comite"> | $Enums.ResultadoDefensa | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    propuesta?: XOR<PropuestaRelationFilter, PropuestaWhereInput>
  }, "usuariosId_propuestasId">

  export type ComiteOrderByWithAggregationInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrderInput | SortOrder
    fechaAsignada?: SortOrderInput | SortOrder
    fechaDefensa?: SortOrderInput | SortOrder
    resultadoDefensa?: SortOrderInput | SortOrder
    _count?: ComiteCountOrderByAggregateInput
    _avg?: ComiteAvgOrderByAggregateInput
    _max?: ComiteMaxOrderByAggregateInput
    _min?: ComiteMinOrderByAggregateInput
    _sum?: ComiteSumOrderByAggregateInput
  }

  export type ComiteScalarWhereWithAggregatesInput = {
    AND?: ComiteScalarWhereWithAggregatesInput | ComiteScalarWhereWithAggregatesInput[]
    OR?: ComiteScalarWhereWithAggregatesInput[]
    NOT?: ComiteScalarWhereWithAggregatesInput | ComiteScalarWhereWithAggregatesInput[]
    usuariosId?: IntWithAggregatesFilter<"Comite"> | number
    propuestasId?: IntWithAggregatesFilter<"Comite"> | number
    rol?: EnumRolComiteWithAggregatesFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableWithAggregatesFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableWithAggregatesFilter<"Comite"> | Date | string | null
    fechaDefensa?: DateTimeNullableWithAggregatesFilter<"Comite"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableWithAggregatesFilter<"Comite"> | $Enums.ResultadoDefensa | null
  }

  export type UsuarioCreateInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropuestaCreateInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado?: number | null
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaCreateManyInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado?: number | null
  }

  export type PropuestaUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PropuestaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActividadCreateInput = {
    nombre?: string | null
    descripcion?: string | null
    propuesta: PropuestaCreateNestedOneWithoutActividadesInput
    usuario: UsuarioCreateNestedOneWithoutActividadesCreadasInput
    evidencias?: EvidenciaCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    propuestasId: number
    usuariosId: number
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuesta?: PropuestaUpdateOneRequiredWithoutActividadesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutActividadesCreadasNestedInput
    evidencias?: EvidenciaUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestasId?: IntFieldUpdateOperationsInput | number
    usuariosId?: IntFieldUpdateOperationsInput | number
    evidencias?: EvidenciaUncheckedUpdateManyWithoutActividadNestedInput
  }

  export type ActividadCreateManyInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    propuestasId: number
    usuariosId: number
  }

  export type ActividadUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActividadUncheckedUpdateManyInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestasId?: IntFieldUpdateOperationsInput | number
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type EvidenciaCreateInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividad: ActividadCreateNestedOneWithoutEvidenciasInput
    comentarios?: ComentarioCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadesId: number
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUpdateInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividad?: ActividadUpdateOneRequiredWithoutEvidenciasNestedInput
    comentarios?: ComentarioUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFieldUpdateOperationsInput | number
    comentarios?: ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaCreateManyInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadesId: number
  }

  export type EvidenciaUpdateManyMutationInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EvidenciaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioCreateInput = {
    descripcion?: string | null
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateInput = {
    idComentarios?: number
    descripcion?: string | null
    evidenciaId: number
    usuariosId: number
  }

  export type ComentarioUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidenciaId?: IntFieldUpdateOperationsInput | number
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioCreateManyInput = {
    idComentarios?: number
    descripcion?: string | null
    evidenciaId: number
    usuariosId: number
  }

  export type ComentarioUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComentarioUncheckedUpdateManyInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidenciaId?: IntFieldUpdateOperationsInput | number
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type PrerequisitoCreateInput = {
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
    estudiante: UsuarioCreateNestedOneWithoutPrerequisitosInput
  }

  export type PrerequisitoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
    fkEstudiante: number
  }

  export type PrerequisitoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPrerequisitosNestedInput
  }

  export type PrerequisitoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }

  export type PrerequisitoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
    fkEstudiante: number
  }

  export type PrerequisitoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrerequisitoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fkEstudiante?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionCreateInput = {
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuario: UsuarioCreateNestedOneWithoutNotificacionesInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuariosId: number
  }

  export type NotificacionUpdateInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionCreateManyInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
    usuariosId: number
  }

  export type NotificacionUpdateManyMutationInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type EntregableFinalCreateInput = {
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuesta: PropuestaCreateNestedOneWithoutEntregablesFinalesInput
  }

  export type EntregableFinalUncheckedCreateInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuestasId: number
  }

  export type EntregableFinalUpdateInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuesta?: PropuestaUpdateOneRequiredWithoutEntregablesFinalesNestedInput
  }

  export type EntregableFinalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestasId?: IntFieldUpdateOperationsInput | number
  }

  export type EntregableFinalCreateManyInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
    propuestasId: number
  }

  export type EntregableFinalUpdateManyMutationInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestasId?: IntFieldUpdateOperationsInput | number
  }

  export type ComiteCreateInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    usuario: UsuarioCreateNestedOneWithoutComiteAsignacionesInput
    propuesta: PropuestaCreateNestedOneWithoutComiteAsignacionesInput
  }

  export type ComiteUncheckedCreateInput = {
    usuariosId: number
    propuestasId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type ComiteUpdateInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    usuario?: UsuarioUpdateOneRequiredWithoutComiteAsignacionesNestedInput
    propuesta?: PropuestaUpdateOneRequiredWithoutComiteAsignacionesNestedInput
  }

  export type ComiteUncheckedUpdateInput = {
    usuariosId?: IntFieldUpdateOperationsInput | number
    propuestasId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type ComiteCreateManyInput = {
    usuariosId: number
    propuestasId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type ComiteUpdateManyMutationInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type ComiteUncheckedUpdateManyInput = {
    usuariosId?: IntFieldUpdateOperationsInput | number
    propuestasId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PropuestaListRelationFilter = {
    every?: PropuestaWhereInput
    some?: PropuestaWhereInput
    none?: PropuestaWhereInput
  }

  export type ActividadListRelationFilter = {
    every?: ActividadWhereInput
    some?: ActividadWhereInput
    none?: ActividadWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: ComentarioWhereInput
    some?: ComentarioWhereInput
    none?: ComentarioWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type ComiteListRelationFilter = {
    every?: ComiteWhereInput
    some?: ComiteWhereInput
    none?: ComiteWhereInput
  }

  export type PrerequisitoListRelationFilter = {
    every?: PrerequisitoWhereInput
    some?: PrerequisitoWhereInput
    none?: PrerequisitoWhereInput
  }

  export type PropuestaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrerequisitoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    clave?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    clave?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    correoInstitucional?: SortOrder
    clave?: SortOrder
    rol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAreaInvestigacionFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaInvestigacion | EnumAreaInvestigacionFieldRefInput<$PrismaModel>
    in?: $Enums.AreaInvestigacion[]
    notIn?: $Enums.AreaInvestigacion[]
    not?: NestedEnumAreaInvestigacionFilter<$PrismaModel> | $Enums.AreaInvestigacion
  }

  export type EnumEstadoPropuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaFilter<$PrismaModel> | $Enums.EstadoPropuesta
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type EntregableFinalListRelationFilter = {
    every?: EntregableFinalWhereInput
    some?: EntregableFinalWhereInput
    none?: EntregableFinalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EntregableFinalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropuestaCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaInvestigacion?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrder
  }

  export type PropuestaAvgOrderByAggregateInput = {
    id?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrder
  }

  export type PropuestaMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaInvestigacion?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrder
  }

  export type PropuestaMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    objetivos?: SortOrder
    problematica?: SortOrder
    areaInvestigacion?: SortOrder
    alcance?: SortOrder
    archivoUrl?: SortOrder
    fechaPublicacion?: SortOrder
    estado?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrder
  }

  export type PropuestaSumOrderByAggregateInput = {
    id?: SortOrder
    fkEstudiante?: SortOrder
    aprobado?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAreaInvestigacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaInvestigacion | EnumAreaInvestigacionFieldRefInput<$PrismaModel>
    in?: $Enums.AreaInvestigacion[]
    notIn?: $Enums.AreaInvestigacion[]
    not?: NestedEnumAreaInvestigacionWithAggregatesFilter<$PrismaModel> | $Enums.AreaInvestigacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaInvestigacionFilter<$PrismaModel>
    _max?: NestedEnumAreaInvestigacionFilter<$PrismaModel>
  }

  export type EnumEstadoPropuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPropuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
    _max?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PropuestaRelationFilter = {
    is?: PropuestaWhereInput
    isNot?: PropuestaWhereInput
  }

  export type EvidenciaListRelationFilter = {
    every?: EvidenciaWhereInput
    some?: EvidenciaWhereInput
    none?: EvidenciaWhereInput
  }

  export type EvidenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActividadCountOrderByAggregateInput = {
    idActividades?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ActividadAvgOrderByAggregateInput = {
    idActividades?: SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ActividadMaxOrderByAggregateInput = {
    idActividades?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ActividadMinOrderByAggregateInput = {
    idActividades?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ActividadSumOrderByAggregateInput = {
    idActividades?: SortOrder
    propuestasId?: SortOrder
    usuariosId?: SortOrder
  }

  export type EnumEstadoEvidenciaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaFilter<$PrismaModel> | $Enums.EstadoEvidencia
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ActividadRelationFilter = {
    is?: ActividadWhereInput
    isNot?: ActividadWhereInput
  }

  export type EvidenciaCountOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadesId?: SortOrder
  }

  export type EvidenciaAvgOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    calificacion?: SortOrder
    actividadesId?: SortOrder
  }

  export type EvidenciaMaxOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadesId?: SortOrder
  }

  export type EvidenciaMinOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    contenido?: SortOrder
    archivoUrl?: SortOrder
    fechaEntrega?: SortOrder
    estado?: SortOrder
    calificacion?: SortOrder
    actividadesId?: SortOrder
  }

  export type EvidenciaSumOrderByAggregateInput = {
    id?: SortOrder
    semana?: SortOrder
    calificacion?: SortOrder
    actividadesId?: SortOrder
  }

  export type EnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEvidencia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
    _max?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EvidenciaRelationFilter = {
    is?: EvidenciaWhereInput
    isNot?: EvidenciaWhereInput
  }

  export type ComentarioCountOrderByAggregateInput = {
    idComentarios?: SortOrder
    descripcion?: SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ComentarioAvgOrderByAggregateInput = {
    idComentarios?: SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ComentarioMaxOrderByAggregateInput = {
    idComentarios?: SortOrder
    descripcion?: SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ComentarioMinOrderByAggregateInput = {
    idComentarios?: SortOrder
    descripcion?: SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
  }

  export type ComentarioSumOrderByAggregateInput = {
    idComentarios?: SortOrder
    evidenciaId?: SortOrder
    usuariosId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PrerequisitoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type PrerequisitoAvgOrderByAggregateInput = {
    id?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type PrerequisitoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type PrerequisitoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    cumplido?: SortOrder
    archivoUrl?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type PrerequisitoSumOrderByAggregateInput = {
    id?: SortOrder
    fkEstudiante?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuariosId?: SortOrder
  }

  export type NotificacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuariosId?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuariosId?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    mensaje?: SortOrder
    leido?: SortOrder
    fechaCreacion?: SortOrder
    usuariosId?: SortOrder
  }

  export type NotificacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuariosId?: SortOrder
  }

  export type EnumTipoEntregableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableFilter<$PrismaModel> | $Enums.TipoEntregable
  }

  export type EntregableFinalCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalAvgOrderByAggregateInput = {
    id?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    urlArchivo?: SortOrder
    fechaSubida?: SortOrder
    propuestasId?: SortOrder
  }

  export type EntregableFinalSumOrderByAggregateInput = {
    id?: SortOrder
    propuestasId?: SortOrder
  }

  export type EnumTipoEntregableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel> | $Enums.TipoEntregable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEntregableFilter<$PrismaModel>
    _max?: NestedEnumTipoEntregableFilter<$PrismaModel>
  }

  export type EnumRolComiteFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteFilter<$PrismaModel> | $Enums.RolComite
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumResultadoDefensaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
  }

  export type ComiteUsuariosIdPropuestasIdCompoundUniqueInput = {
    usuariosId: number
    propuestasId: number
  }

  export type ComiteCountOrderByAggregateInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type ComiteAvgOrderByAggregateInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    calificacion?: SortOrder
  }

  export type ComiteMaxOrderByAggregateInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type ComiteMinOrderByAggregateInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    rol?: SortOrder
    calificacion?: SortOrder
    fechaAsignada?: SortOrder
    fechaDefensa?: SortOrder
    resultadoDefensa?: SortOrder
  }

  export type ComiteSumOrderByAggregateInput = {
    usuariosId?: SortOrder
    propuestasId?: SortOrder
    calificacion?: SortOrder
  }

  export type EnumRolComiteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteWithAggregatesFilter<$PrismaModel> | $Enums.RolComite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolComiteFilter<$PrismaModel>
    _max?: NestedEnumRolComiteFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
    _max?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
  }

  export type PropuestaCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type ActividadCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput> | ActividadCreateWithoutUsuarioInput[] | ActividadUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutUsuarioInput | ActividadCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActividadCreateManyUsuarioInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type NotificacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type ComiteCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type PrerequisitoCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput> | PrerequisitoCreateWithoutEstudianteInput[] | PrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PrerequisitoCreateOrConnectWithoutEstudianteInput | PrerequisitoCreateOrConnectWithoutEstudianteInput[]
    createMany?: PrerequisitoCreateManyEstudianteInputEnvelope
    connect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
  }

  export type PropuestaUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
  }

  export type ActividadUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput> | ActividadCreateWithoutUsuarioInput[] | ActividadUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutUsuarioInput | ActividadCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActividadCreateManyUsuarioInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type NotificacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type ComiteUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput> | PrerequisitoCreateWithoutEstudianteInput[] | PrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PrerequisitoCreateOrConnectWithoutEstudianteInput | PrerequisitoCreateOrConnectWithoutEstudianteInput[]
    createMany?: PrerequisitoCreateManyEstudianteInputEnvelope
    connect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PropuestaUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutEstudianteInput | PropuestaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutEstudianteInput | PropuestaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutEstudianteInput | PropuestaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type ActividadUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput> | ActividadCreateWithoutUsuarioInput[] | ActividadUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutUsuarioInput | ActividadCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutUsuarioInput | ActividadUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActividadCreateManyUsuarioInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutUsuarioInput | ActividadUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutUsuarioInput | ActividadUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type NotificacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type ComiteUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutUsuarioInput | ComiteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutUsuarioInput | ComiteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutUsuarioInput | ComiteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type PrerequisitoUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput> | PrerequisitoCreateWithoutEstudianteInput[] | PrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PrerequisitoCreateOrConnectWithoutEstudianteInput | PrerequisitoCreateOrConnectWithoutEstudianteInput[]
    upsert?: PrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput | PrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PrerequisitoCreateManyEstudianteInputEnvelope
    set?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    disconnect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    delete?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    connect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    update?: PrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput | PrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PrerequisitoUpdateManyWithWhereWithoutEstudianteInput | PrerequisitoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PrerequisitoScalarWhereInput | PrerequisitoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput> | PropuestaCreateWithoutEstudianteInput[] | PropuestaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PropuestaCreateOrConnectWithoutEstudianteInput | PropuestaCreateOrConnectWithoutEstudianteInput[]
    upsert?: PropuestaUpsertWithWhereUniqueWithoutEstudianteInput | PropuestaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PropuestaCreateManyEstudianteInputEnvelope
    set?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    disconnect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    delete?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    connect?: PropuestaWhereUniqueInput | PropuestaWhereUniqueInput[]
    update?: PropuestaUpdateWithWhereUniqueWithoutEstudianteInput | PropuestaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PropuestaUpdateManyWithWhereWithoutEstudianteInput | PropuestaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
  }

  export type ActividadUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput> | ActividadCreateWithoutUsuarioInput[] | ActividadUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutUsuarioInput | ActividadCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutUsuarioInput | ActividadUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActividadCreateManyUsuarioInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutUsuarioInput | ActividadUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutUsuarioInput | ActividadUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput> | ComentarioCreateWithoutUsuarioInput[] | ComentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutUsuarioInput | ComentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutUsuarioInput | ComentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComentarioCreateManyUsuarioInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutUsuarioInput | ComentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutUsuarioInput | ComentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput> | NotificacionCreateWithoutUsuarioInput[] | NotificacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutUsuarioInput | NotificacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutUsuarioInput | NotificacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: NotificacionCreateManyUsuarioInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutUsuarioInput | NotificacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutUsuarioInput | NotificacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type ComiteUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput> | ComiteCreateWithoutUsuarioInput[] | ComiteUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutUsuarioInput | ComiteCreateOrConnectWithoutUsuarioInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutUsuarioInput | ComiteUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ComiteCreateManyUsuarioInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutUsuarioInput | ComiteUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutUsuarioInput | ComiteUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput> | PrerequisitoCreateWithoutEstudianteInput[] | PrerequisitoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: PrerequisitoCreateOrConnectWithoutEstudianteInput | PrerequisitoCreateOrConnectWithoutEstudianteInput[]
    upsert?: PrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput | PrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: PrerequisitoCreateManyEstudianteInputEnvelope
    set?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    disconnect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    delete?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    connect?: PrerequisitoWhereUniqueInput | PrerequisitoWhereUniqueInput[]
    update?: PrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput | PrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: PrerequisitoUpdateManyWithWhereWithoutEstudianteInput | PrerequisitoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: PrerequisitoScalarWhereInput | PrerequisitoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPropuestasInput = {
    create?: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPropuestasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ActividadCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComiteCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EntregableFinalCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
  }

  export type ActividadUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
  }

  export type ComiteUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
  }

  export type EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAreaInvestigacionFieldUpdateOperationsInput = {
    set?: $Enums.AreaInvestigacion
  }

  export type EnumEstadoPropuestaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPropuesta
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutPropuestasNestedInput = {
    create?: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPropuestasInput
    upsert?: UsuarioUpsertWithoutPropuestasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPropuestasInput, UsuarioUpdateWithoutPropuestasInput>, UsuarioUncheckedUpdateWithoutPropuestasInput>
  }

  export type ActividadUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutPropuestaInput | ActividadUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutPropuestaInput | ActividadUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutPropuestaInput | ActividadUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComiteUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutPropuestaInput | ComiteUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutPropuestaInput | ComiteUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutPropuestaInput | ComiteUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EntregableFinalUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    upsert?: EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    set?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    disconnect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    delete?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    update?: EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: EntregableFinalUpdateManyWithWhereWithoutPropuestaInput | EntregableFinalUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
  }

  export type ActividadUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput> | ActividadCreateWithoutPropuestaInput[] | ActividadUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ActividadCreateOrConnectWithoutPropuestaInput | ActividadCreateOrConnectWithoutPropuestaInput[]
    upsert?: ActividadUpsertWithWhereUniqueWithoutPropuestaInput | ActividadUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ActividadCreateManyPropuestaInputEnvelope
    set?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    disconnect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    delete?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    connect?: ActividadWhereUniqueInput | ActividadWhereUniqueInput[]
    update?: ActividadUpdateWithWhereUniqueWithoutPropuestaInput | ActividadUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ActividadUpdateManyWithWhereWithoutPropuestaInput | ActividadUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
  }

  export type ComiteUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput> | ComiteCreateWithoutPropuestaInput[] | ComiteUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: ComiteCreateOrConnectWithoutPropuestaInput | ComiteCreateOrConnectWithoutPropuestaInput[]
    upsert?: ComiteUpsertWithWhereUniqueWithoutPropuestaInput | ComiteUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: ComiteCreateManyPropuestaInputEnvelope
    set?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    disconnect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    delete?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    connect?: ComiteWhereUniqueInput | ComiteWhereUniqueInput[]
    update?: ComiteUpdateWithWhereUniqueWithoutPropuestaInput | ComiteUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: ComiteUpdateManyWithWhereWithoutPropuestaInput | ComiteUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
  }

  export type EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput = {
    create?: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput> | EntregableFinalCreateWithoutPropuestaInput[] | EntregableFinalUncheckedCreateWithoutPropuestaInput[]
    connectOrCreate?: EntregableFinalCreateOrConnectWithoutPropuestaInput | EntregableFinalCreateOrConnectWithoutPropuestaInput[]
    upsert?: EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput[]
    createMany?: EntregableFinalCreateManyPropuestaInputEnvelope
    set?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    disconnect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    delete?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    connect?: EntregableFinalWhereUniqueInput | EntregableFinalWhereUniqueInput[]
    update?: EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput | EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput[]
    updateMany?: EntregableFinalUpdateManyWithWhereWithoutPropuestaInput | EntregableFinalUpdateManyWithWhereWithoutPropuestaInput[]
    deleteMany?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
  }

  export type PropuestaCreateNestedOneWithoutActividadesInput = {
    create?: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutActividadesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutActividadesCreadasInput = {
    create?: XOR<UsuarioCreateWithoutActividadesCreadasInput, UsuarioUncheckedCreateWithoutActividadesCreadasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActividadesCreadasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EvidenciaCreateNestedManyWithoutActividadInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type EvidenciaUncheckedCreateNestedManyWithoutActividadInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
  }

  export type PropuestaUpdateOneRequiredWithoutActividadesNestedInput = {
    create?: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutActividadesInput
    upsert?: PropuestaUpsertWithoutActividadesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutActividadesInput, PropuestaUpdateWithoutActividadesInput>, PropuestaUncheckedUpdateWithoutActividadesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutActividadesCreadasNestedInput = {
    create?: XOR<UsuarioCreateWithoutActividadesCreadasInput, UsuarioUncheckedCreateWithoutActividadesCreadasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutActividadesCreadasInput
    upsert?: UsuarioUpsertWithoutActividadesCreadasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutActividadesCreadasInput, UsuarioUpdateWithoutActividadesCreadasInput>, UsuarioUncheckedUpdateWithoutActividadesCreadasInput>
  }

  export type EvidenciaUpdateManyWithoutActividadNestedInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutActividadInput | EvidenciaUpsertWithWhereUniqueWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutActividadInput | EvidenciaUpdateWithWhereUniqueWithoutActividadInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutActividadInput | EvidenciaUpdateManyWithWhereWithoutActividadInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type EvidenciaUncheckedUpdateManyWithoutActividadNestedInput = {
    create?: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput> | EvidenciaCreateWithoutActividadInput[] | EvidenciaUncheckedCreateWithoutActividadInput[]
    connectOrCreate?: EvidenciaCreateOrConnectWithoutActividadInput | EvidenciaCreateOrConnectWithoutActividadInput[]
    upsert?: EvidenciaUpsertWithWhereUniqueWithoutActividadInput | EvidenciaUpsertWithWhereUniqueWithoutActividadInput[]
    createMany?: EvidenciaCreateManyActividadInputEnvelope
    set?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    disconnect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    delete?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    connect?: EvidenciaWhereUniqueInput | EvidenciaWhereUniqueInput[]
    update?: EvidenciaUpdateWithWhereUniqueWithoutActividadInput | EvidenciaUpdateWithWhereUniqueWithoutActividadInput[]
    updateMany?: EvidenciaUpdateManyWithWhereWithoutActividadInput | EvidenciaUpdateManyWithWhereWithoutActividadInput[]
    deleteMany?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
  }

  export type ActividadCreateNestedOneWithoutEvidenciasInput = {
    create?: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutEvidenciasInput
    connect?: ActividadWhereUniqueInput
  }

  export type ComentarioCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
  }

  export type EnumEstadoEvidenciaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoEvidencia
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ActividadUpdateOneRequiredWithoutEvidenciasNestedInput = {
    create?: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    connectOrCreate?: ActividadCreateOrConnectWithoutEvidenciasInput
    upsert?: ActividadUpsertWithoutEvidenciasInput
    connect?: ActividadWhereUniqueInput
    update?: XOR<XOR<ActividadUpdateToOneWithWhereWithoutEvidenciasInput, ActividadUpdateWithoutEvidenciasInput>, ActividadUncheckedUpdateWithoutEvidenciasInput>
  }

  export type ComentarioUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutEvidenciaInput | ComentarioUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput = {
    create?: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput> | ComentarioCreateWithoutEvidenciaInput[] | ComentarioUncheckedCreateWithoutEvidenciaInput[]
    connectOrCreate?: ComentarioCreateOrConnectWithoutEvidenciaInput | ComentarioCreateOrConnectWithoutEvidenciaInput[]
    upsert?: ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput | ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput[]
    createMany?: ComentarioCreateManyEvidenciaInputEnvelope
    set?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    disconnect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    delete?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    connect?: ComentarioWhereUniqueInput | ComentarioWhereUniqueInput[]
    update?: ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput | ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput[]
    updateMany?: ComentarioUpdateManyWithWhereWithoutEvidenciaInput | ComentarioUpdateManyWithWhereWithoutEvidenciaInput[]
    deleteMany?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
  }

  export type EvidenciaCreateNestedOneWithoutComentariosInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EvidenciaUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: EvidenciaCreateOrConnectWithoutComentariosInput
    upsert?: EvidenciaUpsertWithoutComentariosInput
    connect?: EvidenciaWhereUniqueInput
    update?: XOR<XOR<EvidenciaUpdateToOneWithWhereWithoutComentariosInput, EvidenciaUpdateWithoutComentariosInput>, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComentariosInput
    upsert?: UsuarioUpsertWithoutComentariosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComentariosInput, UsuarioUpdateWithoutComentariosInput>, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioCreateNestedOneWithoutPrerequisitosInput = {
    create?: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrerequisitosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsuarioUpdateOneRequiredWithoutPrerequisitosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPrerequisitosInput
    upsert?: UsuarioUpsertWithoutPrerequisitosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPrerequisitosInput, UsuarioUpdateWithoutPrerequisitosInput>, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
  }

  export type UsuarioCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutNotificacionesInput
    upsert?: UsuarioUpsertWithoutNotificacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutNotificacionesInput, UsuarioUpdateWithoutNotificacionesInput>, UsuarioUncheckedUpdateWithoutNotificacionesInput>
  }

  export type PropuestaCreateNestedOneWithoutEntregablesFinalesInput = {
    create?: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutEntregablesFinalesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type EnumTipoEntregableFieldUpdateOperationsInput = {
    set?: $Enums.TipoEntregable
  }

  export type PropuestaUpdateOneRequiredWithoutEntregablesFinalesNestedInput = {
    create?: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutEntregablesFinalesInput
    upsert?: PropuestaUpsertWithoutEntregablesFinalesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutEntregablesFinalesInput, PropuestaUpdateWithoutEntregablesFinalesInput>, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
  }

  export type UsuarioCreateNestedOneWithoutComiteAsignacionesInput = {
    create?: XOR<UsuarioCreateWithoutComiteAsignacionesInput, UsuarioUncheckedCreateWithoutComiteAsignacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComiteAsignacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PropuestaCreateNestedOneWithoutComiteAsignacionesInput = {
    create?: XOR<PropuestaCreateWithoutComiteAsignacionesInput, PropuestaUncheckedCreateWithoutComiteAsignacionesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutComiteAsignacionesInput
    connect?: PropuestaWhereUniqueInput
  }

  export type EnumRolComiteFieldUpdateOperationsInput = {
    set?: $Enums.RolComite
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumResultadoDefensaFieldUpdateOperationsInput = {
    set?: $Enums.ResultadoDefensa | null
  }

  export type UsuarioUpdateOneRequiredWithoutComiteAsignacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutComiteAsignacionesInput, UsuarioUncheckedCreateWithoutComiteAsignacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComiteAsignacionesInput
    upsert?: UsuarioUpsertWithoutComiteAsignacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComiteAsignacionesInput, UsuarioUpdateWithoutComiteAsignacionesInput>, UsuarioUncheckedUpdateWithoutComiteAsignacionesInput>
  }

  export type PropuestaUpdateOneRequiredWithoutComiteAsignacionesNestedInput = {
    create?: XOR<PropuestaCreateWithoutComiteAsignacionesInput, PropuestaUncheckedCreateWithoutComiteAsignacionesInput>
    connectOrCreate?: PropuestaCreateOrConnectWithoutComiteAsignacionesInput
    upsert?: PropuestaUpsertWithoutComiteAsignacionesInput
    connect?: PropuestaWhereUniqueInput
    update?: XOR<XOR<PropuestaUpdateToOneWithWhereWithoutComiteAsignacionesInput, PropuestaUpdateWithoutComiteAsignacionesInput>, PropuestaUncheckedUpdateWithoutComiteAsignacionesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[]
    notIn?: $Enums.Rol[]
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAreaInvestigacionFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaInvestigacion | EnumAreaInvestigacionFieldRefInput<$PrismaModel>
    in?: $Enums.AreaInvestigacion[]
    notIn?: $Enums.AreaInvestigacion[]
    not?: NestedEnumAreaInvestigacionFilter<$PrismaModel> | $Enums.AreaInvestigacion
  }

  export type NestedEnumEstadoPropuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaFilter<$PrismaModel> | $Enums.EstadoPropuesta
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAreaInvestigacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AreaInvestigacion | EnumAreaInvestigacionFieldRefInput<$PrismaModel>
    in?: $Enums.AreaInvestigacion[]
    notIn?: $Enums.AreaInvestigacion[]
    not?: NestedEnumAreaInvestigacionWithAggregatesFilter<$PrismaModel> | $Enums.AreaInvestigacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAreaInvestigacionFilter<$PrismaModel>
    _max?: NestedEnumAreaInvestigacionFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPropuesta | EnumEstadoPropuestaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPropuesta[]
    notIn?: $Enums.EstadoPropuesta[]
    not?: NestedEnumEstadoPropuestaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPropuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
    _max?: NestedEnumEstadoPropuestaFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoEvidenciaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaFilter<$PrismaModel> | $Enums.EstadoEvidencia
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEvidencia | EnumEstadoEvidenciaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEvidencia[]
    notIn?: $Enums.EstadoEvidencia[]
    not?: NestedEnumEstadoEvidenciaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEvidencia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
    _max?: NestedEnumEstadoEvidenciaFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTipoEntregableFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableFilter<$PrismaModel> | $Enums.TipoEntregable
  }

  export type NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEntregable | EnumTipoEntregableFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEntregable[]
    notIn?: $Enums.TipoEntregable[]
    not?: NestedEnumTipoEntregableWithAggregatesFilter<$PrismaModel> | $Enums.TipoEntregable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEntregableFilter<$PrismaModel>
    _max?: NestedEnumTipoEntregableFilter<$PrismaModel>
  }

  export type NestedEnumRolComiteFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteFilter<$PrismaModel> | $Enums.RolComite
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumResultadoDefensaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
  }

  export type NestedEnumRolComiteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolComite | EnumRolComiteFieldRefInput<$PrismaModel>
    in?: $Enums.RolComite[]
    notIn?: $Enums.RolComite[]
    not?: NestedEnumRolComiteWithAggregatesFilter<$PrismaModel> | $Enums.RolComite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolComiteFilter<$PrismaModel>
    _max?: NestedEnumRolComiteFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoDefensa | EnumResultadoDefensaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ResultadoDefensa[] | null
    notIn?: $Enums.ResultadoDefensa[] | null
    not?: NestedEnumResultadoDefensaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoDefensa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
    _max?: NestedEnumResultadoDefensaNullableFilter<$PrismaModel>
  }

  export type PropuestaCreateWithoutEstudianteInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutEstudianteInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput>
  }

  export type PropuestaCreateManyEstudianteInputEnvelope = {
    data: PropuestaCreateManyEstudianteInput | PropuestaCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type ActividadCreateWithoutUsuarioInput = {
    nombre?: string | null
    descripcion?: string | null
    propuesta: PropuestaCreateNestedOneWithoutActividadesInput
    evidencias?: EvidenciaCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateWithoutUsuarioInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    propuestasId: number
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadCreateOrConnectWithoutUsuarioInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput>
  }

  export type ActividadCreateManyUsuarioInputEnvelope = {
    data: ActividadCreateManyUsuarioInput | ActividadCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ComentarioCreateWithoutUsuarioInput = {
    descripcion?: string | null
    evidencia: EvidenciaCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutUsuarioInput = {
    idComentarios?: number
    descripcion?: string | null
    evidenciaId: number
  }

  export type ComentarioCreateOrConnectWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioCreateManyUsuarioInputEnvelope = {
    data: ComentarioCreateManyUsuarioInput | ComentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type NotificacionCreateWithoutUsuarioInput = {
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionCreateManyUsuarioInputEnvelope = {
    data: NotificacionCreateManyUsuarioInput | NotificacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ComiteCreateWithoutUsuarioInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    propuesta: PropuestaCreateNestedOneWithoutComiteAsignacionesInput
  }

  export type ComiteUncheckedCreateWithoutUsuarioInput = {
    propuestasId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type ComiteCreateOrConnectWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    create: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput>
  }

  export type ComiteCreateManyUsuarioInputEnvelope = {
    data: ComiteCreateManyUsuarioInput | ComiteCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PrerequisitoCreateWithoutEstudianteInput = {
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
  }

  export type PrerequisitoUncheckedCreateWithoutEstudianteInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
  }

  export type PrerequisitoCreateOrConnectWithoutEstudianteInput = {
    where: PrerequisitoWhereUniqueInput
    create: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput>
  }

  export type PrerequisitoCreateManyEstudianteInputEnvelope = {
    data: PrerequisitoCreateManyEstudianteInput | PrerequisitoCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type PropuestaUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    update: XOR<PropuestaUpdateWithoutEstudianteInput, PropuestaUncheckedUpdateWithoutEstudianteInput>
    create: XOR<PropuestaCreateWithoutEstudianteInput, PropuestaUncheckedCreateWithoutEstudianteInput>
  }

  export type PropuestaUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: PropuestaWhereUniqueInput
    data: XOR<PropuestaUpdateWithoutEstudianteInput, PropuestaUncheckedUpdateWithoutEstudianteInput>
  }

  export type PropuestaUpdateManyWithWhereWithoutEstudianteInput = {
    where: PropuestaScalarWhereInput
    data: XOR<PropuestaUpdateManyMutationInput, PropuestaUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type PropuestaScalarWhereInput = {
    AND?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
    OR?: PropuestaScalarWhereInput[]
    NOT?: PropuestaScalarWhereInput | PropuestaScalarWhereInput[]
    id?: IntFilter<"Propuesta"> | number
    titulo?: StringFilter<"Propuesta"> | string
    objetivos?: StringFilter<"Propuesta"> | string
    problematica?: StringNullableFilter<"Propuesta"> | string | null
    areaInvestigacion?: EnumAreaInvestigacionFilter<"Propuesta"> | $Enums.AreaInvestigacion
    alcance?: StringNullableFilter<"Propuesta"> | string | null
    archivoUrl?: StringNullableFilter<"Propuesta"> | string | null
    fechaPublicacion?: DateTimeFilter<"Propuesta"> | Date | string
    estado?: EnumEstadoPropuestaFilter<"Propuesta"> | $Enums.EstadoPropuesta
    fkEstudiante?: IntFilter<"Propuesta"> | number
    aprobado?: IntNullableFilter<"Propuesta"> | number | null
  }

  export type ActividadUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ActividadWhereUniqueInput
    update: XOR<ActividadUpdateWithoutUsuarioInput, ActividadUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ActividadCreateWithoutUsuarioInput, ActividadUncheckedCreateWithoutUsuarioInput>
  }

  export type ActividadUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ActividadWhereUniqueInput
    data: XOR<ActividadUpdateWithoutUsuarioInput, ActividadUncheckedUpdateWithoutUsuarioInput>
  }

  export type ActividadUpdateManyWithWhereWithoutUsuarioInput = {
    where: ActividadScalarWhereInput
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ActividadScalarWhereInput = {
    AND?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
    OR?: ActividadScalarWhereInput[]
    NOT?: ActividadScalarWhereInput | ActividadScalarWhereInput[]
    idActividades?: IntFilter<"Actividad"> | number
    nombre?: StringNullableFilter<"Actividad"> | string | null
    descripcion?: StringNullableFilter<"Actividad"> | string | null
    propuestasId?: IntFilter<"Actividad"> | number
    usuariosId?: IntFilter<"Actividad"> | number
  }

  export type ComentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComentarioCreateWithoutUsuarioInput, ComentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutUsuarioInput, ComentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComentarioScalarWhereInput = {
    AND?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    OR?: ComentarioScalarWhereInput[]
    NOT?: ComentarioScalarWhereInput | ComentarioScalarWhereInput[]
    idComentarios?: IntFilter<"Comentario"> | number
    descripcion?: StringNullableFilter<"Comentario"> | string | null
    evidenciaId?: IntFilter<"Comentario"> | number
    usuariosId?: IntFilter<"Comentario"> | number
  }

  export type NotificacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<NotificacionCreateWithoutUsuarioInput, NotificacionUncheckedCreateWithoutUsuarioInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutUsuarioInput, NotificacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: IntFilter<"Notificacion"> | number
    mensaje?: StringFilter<"Notificacion"> | string
    leido?: BoolFilter<"Notificacion"> | boolean
    fechaCreacion?: DateTimeFilter<"Notificacion"> | Date | string
    usuariosId?: IntFilter<"Notificacion"> | number
  }

  export type ComiteUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    update: XOR<ComiteUpdateWithoutUsuarioInput, ComiteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ComiteCreateWithoutUsuarioInput, ComiteUncheckedCreateWithoutUsuarioInput>
  }

  export type ComiteUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ComiteWhereUniqueInput
    data: XOR<ComiteUpdateWithoutUsuarioInput, ComiteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComiteUpdateManyWithWhereWithoutUsuarioInput = {
    where: ComiteScalarWhereInput
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ComiteScalarWhereInput = {
    AND?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
    OR?: ComiteScalarWhereInput[]
    NOT?: ComiteScalarWhereInput | ComiteScalarWhereInput[]
    usuariosId?: IntFilter<"Comite"> | number
    propuestasId?: IntFilter<"Comite"> | number
    rol?: EnumRolComiteFilter<"Comite"> | $Enums.RolComite
    calificacion?: DecimalNullableFilter<"Comite"> | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: DateTimeNullableFilter<"Comite"> | Date | string | null
    fechaDefensa?: DateTimeNullableFilter<"Comite"> | Date | string | null
    resultadoDefensa?: EnumResultadoDefensaNullableFilter<"Comite"> | $Enums.ResultadoDefensa | null
  }

  export type PrerequisitoUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: PrerequisitoWhereUniqueInput
    update: XOR<PrerequisitoUpdateWithoutEstudianteInput, PrerequisitoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<PrerequisitoCreateWithoutEstudianteInput, PrerequisitoUncheckedCreateWithoutEstudianteInput>
  }

  export type PrerequisitoUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: PrerequisitoWhereUniqueInput
    data: XOR<PrerequisitoUpdateWithoutEstudianteInput, PrerequisitoUncheckedUpdateWithoutEstudianteInput>
  }

  export type PrerequisitoUpdateManyWithWhereWithoutEstudianteInput = {
    where: PrerequisitoScalarWhereInput
    data: XOR<PrerequisitoUpdateManyMutationInput, PrerequisitoUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type PrerequisitoScalarWhereInput = {
    AND?: PrerequisitoScalarWhereInput | PrerequisitoScalarWhereInput[]
    OR?: PrerequisitoScalarWhereInput[]
    NOT?: PrerequisitoScalarWhereInput | PrerequisitoScalarWhereInput[]
    id?: IntFilter<"Prerequisito"> | number
    nombre?: StringFilter<"Prerequisito"> | string
    descripcion?: StringNullableFilter<"Prerequisito"> | string | null
    cumplido?: BoolFilter<"Prerequisito"> | boolean
    archivoUrl?: StringNullableFilter<"Prerequisito"> | string | null
    fkEstudiante?: IntFilter<"Prerequisito"> | number
  }

  export type UsuarioCreateWithoutPropuestasInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutPropuestasInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutPropuestasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
  }

  export type ActividadCreateWithoutPropuestaInput = {
    nombre?: string | null
    descripcion?: string | null
    usuario: UsuarioCreateNestedOneWithoutActividadesCreadasInput
    evidencias?: EvidenciaCreateNestedManyWithoutActividadInput
  }

  export type ActividadUncheckedCreateWithoutPropuestaInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    usuariosId: number
    evidencias?: EvidenciaUncheckedCreateNestedManyWithoutActividadInput
  }

  export type ActividadCreateOrConnectWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput>
  }

  export type ActividadCreateManyPropuestaInputEnvelope = {
    data: ActividadCreateManyPropuestaInput | ActividadCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type ComiteCreateWithoutPropuestaInput = {
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
    usuario: UsuarioCreateNestedOneWithoutComiteAsignacionesInput
  }

  export type ComiteUncheckedCreateWithoutPropuestaInput = {
    usuariosId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type ComiteCreateOrConnectWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    create: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput>
  }

  export type ComiteCreateManyPropuestaInputEnvelope = {
    data: ComiteCreateManyPropuestaInput | ComiteCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type EntregableFinalCreateWithoutPropuestaInput = {
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type EntregableFinalUncheckedCreateWithoutPropuestaInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type EntregableFinalCreateOrConnectWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    create: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput>
  }

  export type EntregableFinalCreateManyPropuestaInputEnvelope = {
    data: EntregableFinalCreateManyPropuestaInput | EntregableFinalCreateManyPropuestaInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutPropuestasInput = {
    update: XOR<UsuarioUpdateWithoutPropuestasInput, UsuarioUncheckedUpdateWithoutPropuestasInput>
    create: XOR<UsuarioCreateWithoutPropuestasInput, UsuarioUncheckedCreateWithoutPropuestasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPropuestasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPropuestasInput, UsuarioUncheckedUpdateWithoutPropuestasInput>
  }

  export type UsuarioUpdateWithoutPropuestasInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPropuestasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ActividadUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    update: XOR<ActividadUpdateWithoutPropuestaInput, ActividadUncheckedUpdateWithoutPropuestaInput>
    create: XOR<ActividadCreateWithoutPropuestaInput, ActividadUncheckedCreateWithoutPropuestaInput>
  }

  export type ActividadUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: ActividadWhereUniqueInput
    data: XOR<ActividadUpdateWithoutPropuestaInput, ActividadUncheckedUpdateWithoutPropuestaInput>
  }

  export type ActividadUpdateManyWithWhereWithoutPropuestaInput = {
    where: ActividadScalarWhereInput
    data: XOR<ActividadUpdateManyMutationInput, ActividadUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type ComiteUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    update: XOR<ComiteUpdateWithoutPropuestaInput, ComiteUncheckedUpdateWithoutPropuestaInput>
    create: XOR<ComiteCreateWithoutPropuestaInput, ComiteUncheckedCreateWithoutPropuestaInput>
  }

  export type ComiteUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: ComiteWhereUniqueInput
    data: XOR<ComiteUpdateWithoutPropuestaInput, ComiteUncheckedUpdateWithoutPropuestaInput>
  }

  export type ComiteUpdateManyWithWhereWithoutPropuestaInput = {
    where: ComiteScalarWhereInput
    data: XOR<ComiteUpdateManyMutationInput, ComiteUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type EntregableFinalUpsertWithWhereUniqueWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    update: XOR<EntregableFinalUpdateWithoutPropuestaInput, EntregableFinalUncheckedUpdateWithoutPropuestaInput>
    create: XOR<EntregableFinalCreateWithoutPropuestaInput, EntregableFinalUncheckedCreateWithoutPropuestaInput>
  }

  export type EntregableFinalUpdateWithWhereUniqueWithoutPropuestaInput = {
    where: EntregableFinalWhereUniqueInput
    data: XOR<EntregableFinalUpdateWithoutPropuestaInput, EntregableFinalUncheckedUpdateWithoutPropuestaInput>
  }

  export type EntregableFinalUpdateManyWithWhereWithoutPropuestaInput = {
    where: EntregableFinalScalarWhereInput
    data: XOR<EntregableFinalUpdateManyMutationInput, EntregableFinalUncheckedUpdateManyWithoutPropuestaInput>
  }

  export type EntregableFinalScalarWhereInput = {
    AND?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
    OR?: EntregableFinalScalarWhereInput[]
    NOT?: EntregableFinalScalarWhereInput | EntregableFinalScalarWhereInput[]
    id?: IntFilter<"EntregableFinal"> | number
    tipo?: EnumTipoEntregableFilter<"EntregableFinal"> | $Enums.TipoEntregable
    urlArchivo?: StringFilter<"EntregableFinal"> | string
    fechaSubida?: DateTimeFilter<"EntregableFinal"> | Date | string
    propuestasId?: IntFilter<"EntregableFinal"> | number
  }

  export type PropuestaCreateWithoutActividadesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutActividadesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado?: number | null
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutActividadesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
  }

  export type UsuarioCreateWithoutActividadesCreadasInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutActividadesCreadasInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutActividadesCreadasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutActividadesCreadasInput, UsuarioUncheckedCreateWithoutActividadesCreadasInput>
  }

  export type EvidenciaCreateWithoutActividadInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaUncheckedCreateWithoutActividadInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutEvidenciaInput
  }

  export type EvidenciaCreateOrConnectWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput>
  }

  export type EvidenciaCreateManyActividadInputEnvelope = {
    data: EvidenciaCreateManyActividadInput | EvidenciaCreateManyActividadInput[]
    skipDuplicates?: boolean
  }

  export type PropuestaUpsertWithoutActividadesInput = {
    update: XOR<PropuestaUpdateWithoutActividadesInput, PropuestaUncheckedUpdateWithoutActividadesInput>
    create: XOR<PropuestaCreateWithoutActividadesInput, PropuestaUncheckedCreateWithoutActividadesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutActividadesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutActividadesInput, PropuestaUncheckedUpdateWithoutActividadesInput>
  }

  export type PropuestaUpdateWithoutActividadesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutActividadesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type UsuarioUpsertWithoutActividadesCreadasInput = {
    update: XOR<UsuarioUpdateWithoutActividadesCreadasInput, UsuarioUncheckedUpdateWithoutActividadesCreadasInput>
    create: XOR<UsuarioCreateWithoutActividadesCreadasInput, UsuarioUncheckedCreateWithoutActividadesCreadasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutActividadesCreadasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutActividadesCreadasInput, UsuarioUncheckedUpdateWithoutActividadesCreadasInput>
  }

  export type UsuarioUpdateWithoutActividadesCreadasInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutActividadesCreadasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EvidenciaUpsertWithWhereUniqueWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    update: XOR<EvidenciaUpdateWithoutActividadInput, EvidenciaUncheckedUpdateWithoutActividadInput>
    create: XOR<EvidenciaCreateWithoutActividadInput, EvidenciaUncheckedCreateWithoutActividadInput>
  }

  export type EvidenciaUpdateWithWhereUniqueWithoutActividadInput = {
    where: EvidenciaWhereUniqueInput
    data: XOR<EvidenciaUpdateWithoutActividadInput, EvidenciaUncheckedUpdateWithoutActividadInput>
  }

  export type EvidenciaUpdateManyWithWhereWithoutActividadInput = {
    where: EvidenciaScalarWhereInput
    data: XOR<EvidenciaUpdateManyMutationInput, EvidenciaUncheckedUpdateManyWithoutActividadInput>
  }

  export type EvidenciaScalarWhereInput = {
    AND?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    OR?: EvidenciaScalarWhereInput[]
    NOT?: EvidenciaScalarWhereInput | EvidenciaScalarWhereInput[]
    id?: IntFilter<"Evidencia"> | number
    semana?: IntFilter<"Evidencia"> | number
    contenido?: StringFilter<"Evidencia"> | string
    archivoUrl?: StringNullableFilter<"Evidencia"> | string | null
    fechaEntrega?: DateTimeFilter<"Evidencia"> | Date | string
    estado?: EnumEstadoEvidenciaFilter<"Evidencia"> | $Enums.EstadoEvidencia
    calificacion?: DecimalNullableFilter<"Evidencia"> | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFilter<"Evidencia"> | number
  }

  export type ActividadCreateWithoutEvidenciasInput = {
    nombre?: string | null
    descripcion?: string | null
    propuesta: PropuestaCreateNestedOneWithoutActividadesInput
    usuario: UsuarioCreateNestedOneWithoutActividadesCreadasInput
  }

  export type ActividadUncheckedCreateWithoutEvidenciasInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    propuestasId: number
    usuariosId: number
  }

  export type ActividadCreateOrConnectWithoutEvidenciasInput = {
    where: ActividadWhereUniqueInput
    create: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
  }

  export type ComentarioCreateWithoutEvidenciaInput = {
    descripcion?: string | null
    usuario: UsuarioCreateNestedOneWithoutComentariosInput
  }

  export type ComentarioUncheckedCreateWithoutEvidenciaInput = {
    idComentarios?: number
    descripcion?: string | null
    usuariosId: number
  }

  export type ComentarioCreateOrConnectWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    create: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioCreateManyEvidenciaInputEnvelope = {
    data: ComentarioCreateManyEvidenciaInput | ComentarioCreateManyEvidenciaInput[]
    skipDuplicates?: boolean
  }

  export type ActividadUpsertWithoutEvidenciasInput = {
    update: XOR<ActividadUpdateWithoutEvidenciasInput, ActividadUncheckedUpdateWithoutEvidenciasInput>
    create: XOR<ActividadCreateWithoutEvidenciasInput, ActividadUncheckedCreateWithoutEvidenciasInput>
    where?: ActividadWhereInput
  }

  export type ActividadUpdateToOneWithWhereWithoutEvidenciasInput = {
    where?: ActividadWhereInput
    data: XOR<ActividadUpdateWithoutEvidenciasInput, ActividadUncheckedUpdateWithoutEvidenciasInput>
  }

  export type ActividadUpdateWithoutEvidenciasInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuesta?: PropuestaUpdateOneRequiredWithoutActividadesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutActividadesCreadasNestedInput
  }

  export type ActividadUncheckedUpdateWithoutEvidenciasInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestasId?: IntFieldUpdateOperationsInput | number
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioUpsertWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    update: XOR<ComentarioUpdateWithoutEvidenciaInput, ComentarioUncheckedUpdateWithoutEvidenciaInput>
    create: XOR<ComentarioCreateWithoutEvidenciaInput, ComentarioUncheckedCreateWithoutEvidenciaInput>
  }

  export type ComentarioUpdateWithWhereUniqueWithoutEvidenciaInput = {
    where: ComentarioWhereUniqueInput
    data: XOR<ComentarioUpdateWithoutEvidenciaInput, ComentarioUncheckedUpdateWithoutEvidenciaInput>
  }

  export type ComentarioUpdateManyWithWhereWithoutEvidenciaInput = {
    where: ComentarioScalarWhereInput
    data: XOR<ComentarioUpdateManyMutationInput, ComentarioUncheckedUpdateManyWithoutEvidenciaInput>
  }

  export type EvidenciaCreateWithoutComentariosInput = {
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividad: ActividadCreateNestedOneWithoutEvidenciasInput
  }

  export type EvidenciaUncheckedCreateWithoutComentariosInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
    actividadesId: number
  }

  export type EvidenciaCreateOrConnectWithoutComentariosInput = {
    where: EvidenciaWhereUniqueInput
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
  }

  export type UsuarioCreateWithoutComentariosInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutComentariosInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutComentariosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
  }

  export type EvidenciaUpsertWithoutComentariosInput = {
    update: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
    create: XOR<EvidenciaCreateWithoutComentariosInput, EvidenciaUncheckedCreateWithoutComentariosInput>
    where?: EvidenciaWhereInput
  }

  export type EvidenciaUpdateToOneWithWhereWithoutComentariosInput = {
    where?: EvidenciaWhereInput
    data: XOR<EvidenciaUpdateWithoutComentariosInput, EvidenciaUncheckedUpdateWithoutComentariosInput>
  }

  export type EvidenciaUpdateWithoutComentariosInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividad?: ActividadUpdateOneRequiredWithoutEvidenciasNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actividadesId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpsertWithoutComentariosInput = {
    update: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<UsuarioCreateWithoutComentariosInput, UsuarioUncheckedCreateWithoutComentariosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComentariosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComentariosInput, UsuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type UsuarioUpdateWithoutComentariosInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComentariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioCreateWithoutPrerequisitosInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPrerequisitosInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPrerequisitosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
  }

  export type UsuarioUpsertWithoutPrerequisitosInput = {
    update: XOR<UsuarioUpdateWithoutPrerequisitosInput, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
    create: XOR<UsuarioCreateWithoutPrerequisitosInput, UsuarioUncheckedCreateWithoutPrerequisitosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPrerequisitosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPrerequisitosInput, UsuarioUncheckedUpdateWithoutPrerequisitosInput>
  }

  export type UsuarioUpdateWithoutPrerequisitosInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPrerequisitosInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutNotificacionesInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutNotificacionesInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutNotificacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
  }

  export type UsuarioUpsertWithoutNotificacionesInput = {
    update: XOR<UsuarioUpdateWithoutNotificacionesInput, UsuarioUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<UsuarioCreateWithoutNotificacionesInput, UsuarioUncheckedCreateWithoutNotificacionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutNotificacionesInput, UsuarioUncheckedUpdateWithoutNotificacionesInput>
  }

  export type UsuarioUpdateWithoutNotificacionesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutNotificacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type PropuestaCreateWithoutEntregablesFinalesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutEntregablesFinalesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado?: number | null
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    comiteAsignaciones?: ComiteUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutEntregablesFinalesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
  }

  export type PropuestaUpsertWithoutEntregablesFinalesInput = {
    update: XOR<PropuestaUpdateWithoutEntregablesFinalesInput, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
    create: XOR<PropuestaCreateWithoutEntregablesFinalesInput, PropuestaUncheckedCreateWithoutEntregablesFinalesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutEntregablesFinalesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutEntregablesFinalesInput, PropuestaUncheckedUpdateWithoutEntregablesFinalesInput>
  }

  export type PropuestaUpdateWithoutEntregablesFinalesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutEntregablesFinalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type UsuarioCreateWithoutComiteAsignacionesInput = {
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioUncheckedCreateWithoutComiteAsignacionesInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    correoInstitucional: string
    clave: string
    rol?: $Enums.Rol
    createdAt?: Date | string
    updatedAt?: Date | string
    propuestas?: PropuestaUncheckedCreateNestedManyWithoutEstudianteInput
    actividadesCreadas?: ActividadUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: ComentarioUncheckedCreateNestedManyWithoutUsuarioInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutUsuarioInput
    prerequisitos?: PrerequisitoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type UsuarioCreateOrConnectWithoutComiteAsignacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComiteAsignacionesInput, UsuarioUncheckedCreateWithoutComiteAsignacionesInput>
  }

  export type PropuestaCreateWithoutComiteAsignacionesInput = {
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
    estudiante: UsuarioCreateNestedOneWithoutPropuestasInput
    actividades?: ActividadCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaUncheckedCreateWithoutComiteAsignacionesInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    fkEstudiante: number
    aprobado?: number | null
    actividades?: ActividadUncheckedCreateNestedManyWithoutPropuestaInput
    entregablesFinales?: EntregableFinalUncheckedCreateNestedManyWithoutPropuestaInput
  }

  export type PropuestaCreateOrConnectWithoutComiteAsignacionesInput = {
    where: PropuestaWhereUniqueInput
    create: XOR<PropuestaCreateWithoutComiteAsignacionesInput, PropuestaUncheckedCreateWithoutComiteAsignacionesInput>
  }

  export type UsuarioUpsertWithoutComiteAsignacionesInput = {
    update: XOR<UsuarioUpdateWithoutComiteAsignacionesInput, UsuarioUncheckedUpdateWithoutComiteAsignacionesInput>
    create: XOR<UsuarioCreateWithoutComiteAsignacionesInput, UsuarioUncheckedCreateWithoutComiteAsignacionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComiteAsignacionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComiteAsignacionesInput, UsuarioUncheckedUpdateWithoutComiteAsignacionesInput>
  }

  export type UsuarioUpdateWithoutComiteAsignacionesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUpdateManyWithoutEstudianteNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComiteAsignacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    correoInstitucional?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    propuestas?: PropuestaUncheckedUpdateManyWithoutEstudianteNestedInput
    actividadesCreadas?: ActividadUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: ComentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutUsuarioNestedInput
    prerequisitos?: PrerequisitoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type PropuestaUpsertWithoutComiteAsignacionesInput = {
    update: XOR<PropuestaUpdateWithoutComiteAsignacionesInput, PropuestaUncheckedUpdateWithoutComiteAsignacionesInput>
    create: XOR<PropuestaCreateWithoutComiteAsignacionesInput, PropuestaUncheckedCreateWithoutComiteAsignacionesInput>
    where?: PropuestaWhereInput
  }

  export type PropuestaUpdateToOneWithWhereWithoutComiteAsignacionesInput = {
    where?: PropuestaWhereInput
    data: XOR<PropuestaUpdateWithoutComiteAsignacionesInput, PropuestaUncheckedUpdateWithoutComiteAsignacionesInput>
  }

  export type PropuestaUpdateWithoutComiteAsignacionesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    estudiante?: UsuarioUpdateOneRequiredWithoutPropuestasNestedInput
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutComiteAsignacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    fkEstudiante?: IntFieldUpdateOperationsInput | number
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaCreateManyEstudianteInput = {
    id?: number
    titulo: string
    objetivos: string
    problematica?: string | null
    areaInvestigacion: $Enums.AreaInvestigacion
    alcance?: string | null
    archivoUrl?: string | null
    fechaPublicacion?: Date | string
    estado?: $Enums.EstadoPropuesta
    aprobado?: number | null
  }

  export type ActividadCreateManyUsuarioInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    propuestasId: number
  }

  export type ComentarioCreateManyUsuarioInput = {
    idComentarios?: number
    descripcion?: string | null
    evidenciaId: number
  }

  export type NotificacionCreateManyUsuarioInput = {
    id?: number
    mensaje: string
    leido?: boolean
    fechaCreacion?: Date | string
  }

  export type ComiteCreateManyUsuarioInput = {
    propuestasId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type PrerequisitoCreateManyEstudianteInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    cumplido?: boolean
    archivoUrl?: string | null
  }

  export type PropuestaUpdateWithoutEstudianteInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    actividades?: ActividadUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
    actividades?: ActividadUncheckedUpdateManyWithoutPropuestaNestedInput
    comiteAsignaciones?: ComiteUncheckedUpdateManyWithoutPropuestaNestedInput
    entregablesFinales?: EntregableFinalUncheckedUpdateManyWithoutPropuestaNestedInput
  }

  export type PropuestaUncheckedUpdateManyWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    objetivos?: StringFieldUpdateOperationsInput | string
    problematica?: NullableStringFieldUpdateOperationsInput | string | null
    areaInvestigacion?: EnumAreaInvestigacionFieldUpdateOperationsInput | $Enums.AreaInvestigacion
    alcance?: NullableStringFieldUpdateOperationsInput | string | null
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaPublicacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoPropuestaFieldUpdateOperationsInput | $Enums.EstadoPropuesta
    aprobado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActividadUpdateWithoutUsuarioInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuesta?: PropuestaUpdateOneRequiredWithoutActividadesNestedInput
    evidencias?: EvidenciaUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateWithoutUsuarioInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestasId?: IntFieldUpdateOperationsInput | number
    evidencias?: EvidenciaUncheckedUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateManyWithoutUsuarioInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    propuestasId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioUpdateWithoutUsuarioInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidencia?: EvidenciaUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutUsuarioInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidenciaId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioUncheckedUpdateManyWithoutUsuarioInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    evidenciaId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionUpdateWithoutUsuarioInput = {
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    mensaje?: StringFieldUpdateOperationsInput | string
    leido?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComiteUpdateWithoutUsuarioInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    propuesta?: PropuestaUpdateOneRequiredWithoutComiteAsignacionesNestedInput
  }

  export type ComiteUncheckedUpdateWithoutUsuarioInput = {
    propuestasId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type ComiteUncheckedUpdateManyWithoutUsuarioInput = {
    propuestasId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type PrerequisitoUpdateWithoutEstudianteInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrerequisitoUncheckedUpdateWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrerequisitoUncheckedUpdateManyWithoutEstudianteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    cumplido?: BoolFieldUpdateOperationsInput | boolean
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActividadCreateManyPropuestaInput = {
    idActividades?: number
    nombre?: string | null
    descripcion?: string | null
    usuariosId: number
  }

  export type ComiteCreateManyPropuestaInput = {
    usuariosId: number
    rol: $Enums.RolComite
    calificacion?: Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: Date | string | null
    fechaDefensa?: Date | string | null
    resultadoDefensa?: $Enums.ResultadoDefensa | null
  }

  export type EntregableFinalCreateManyPropuestaInput = {
    id?: number
    tipo: $Enums.TipoEntregable
    urlArchivo: string
    fechaSubida?: Date | string
  }

  export type ActividadUpdateWithoutPropuestaInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutActividadesCreadasNestedInput
    evidencias?: EvidenciaUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateWithoutPropuestaInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosId?: IntFieldUpdateOperationsInput | number
    evidencias?: EvidenciaUncheckedUpdateManyWithoutActividadNestedInput
  }

  export type ActividadUncheckedUpdateManyWithoutPropuestaInput = {
    idActividades?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type ComiteUpdateWithoutPropuestaInput = {
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
    usuario?: UsuarioUpdateOneRequiredWithoutComiteAsignacionesNestedInput
  }

  export type ComiteUncheckedUpdateWithoutPropuestaInput = {
    usuariosId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type ComiteUncheckedUpdateManyWithoutPropuestaInput = {
    usuariosId?: IntFieldUpdateOperationsInput | number
    rol?: EnumRolComiteFieldUpdateOperationsInput | $Enums.RolComite
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fechaAsignada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaDefensa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resultadoDefensa?: NullableEnumResultadoDefensaFieldUpdateOperationsInput | $Enums.ResultadoDefensa | null
  }

  export type EntregableFinalUpdateWithoutPropuestaInput = {
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntregableFinalUncheckedUpdateManyWithoutPropuestaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEntregableFieldUpdateOperationsInput | $Enums.TipoEntregable
    urlArchivo?: StringFieldUpdateOperationsInput | string
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenciaCreateManyActividadInput = {
    id?: number
    semana: number
    contenido: string
    archivoUrl?: string | null
    fechaEntrega?: Date | string
    estado?: $Enums.EstadoEvidencia
    calificacion?: Decimal | DecimalJsLike | number | string | null
  }

  export type EvidenciaUpdateWithoutActividadInput = {
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateWithoutActividadInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comentarios?: ComentarioUncheckedUpdateManyWithoutEvidenciaNestedInput
  }

  export type EvidenciaUncheckedUpdateManyWithoutActividadInput = {
    id?: IntFieldUpdateOperationsInput | number
    semana?: IntFieldUpdateOperationsInput | number
    contenido?: StringFieldUpdateOperationsInput | string
    archivoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaEntrega?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEvidenciaFieldUpdateOperationsInput | $Enums.EstadoEvidencia
    calificacion?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ComentarioCreateManyEvidenciaInput = {
    idComentarios?: number
    descripcion?: string | null
    usuariosId: number
  }

  export type ComentarioUpdateWithoutEvidenciaInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type ComentarioUncheckedUpdateWithoutEvidenciaInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosId?: IntFieldUpdateOperationsInput | number
  }

  export type ComentarioUncheckedUpdateManyWithoutEvidenciaInput = {
    idComentarios?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropuestaCountOutputTypeDefaultArgs instead
     */
    export type PropuestaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropuestaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActividadCountOutputTypeDefaultArgs instead
     */
    export type ActividadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActividadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaCountOutputTypeDefaultArgs instead
     */
    export type EvidenciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropuestaDefaultArgs instead
     */
    export type PropuestaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropuestaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActividadDefaultArgs instead
     */
    export type ActividadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActividadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvidenciaDefaultArgs instead
     */
    export type EvidenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvidenciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioDefaultArgs instead
     */
    export type ComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrerequisitoDefaultArgs instead
     */
    export type PrerequisitoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrerequisitoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificacionDefaultArgs instead
     */
    export type NotificacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EntregableFinalDefaultArgs instead
     */
    export type EntregableFinalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EntregableFinalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComiteDefaultArgs instead
     */
    export type ComiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComiteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}